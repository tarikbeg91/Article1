<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Article Reader Pro (Stream & Local TTS)</title>
    
    <!-- PWA: Inline Web App Manifest -->
    <link rel="manifest" href="data:application/manifest+json,{
        &quot;name&quot;: &quot;рдЖрд░реНрдЯрд┐рдХрд▓ рд░реАрдбрд░ рдкреНрд░реЛ&quot;,
        &quot;short_name&quot;: &quot;рд░реАрдбрд░ рдкреНрд░реЛ&quot;,
        &quot;description&quot;: &quot;рд▓реЗрдЦреЛрдВ рдХреЛ рдкрдврд╝реЗрдВ рдФрд░ рд╕реБрдиреЗрдВред&quot;,
        &quot;start_url&quot;: &quot;.&quot;,
        &quot;display&quot;: &quot;standalone&quot;,
        &quot;background_color&quot;: &quot;#f4f7f6&quot;,
        &quot;theme_color&quot;: &quot;#007bff&quot;,
        &quot;icons&quot;: [
            {
                &quot;src&quot;: &quot;https://cdn-icons-png.flaticon.com/512/864/864348.png&quot;,
                &quot;sizes&quot;: &quot;512x512&quot;,
                &quot;type&quot;: &quot;image/png&quot;,
                &quot;purpose&quot;: &quot;any maskable&quot;
            }
        ]
    }">
    <meta name="theme-color" content="#007bff">

    <script src="https://cdn.jsdelivr.net/npm/@mozilla/readability@0.5.0/Readability.min.js"></script>
    <!-- Dexie.js CDN -->
    <script src="https://unpkg.com/dexie@4.0.1/dist/dexie.js"></script>
    <style>
        :root {
            --bg-color: #f4f7f6; --text-color: #333; --container-bg: #ffffff;
            --primary-color: #007bff; --secondary-color: #17a2b8;
            --border-color: #ddd; --danger-color: #dc3545; --success-color: #28a745;
            --font-size-base: 16px; --line-height-base: 1.6;
            --player-red: #d32f2f; --player-gold: #bcaaa4; --player-light-gray: #e0e0e0;
        }
        .dark-mode {
            --bg-color: #121212; --text-color: #e0e0e0; --container-bg: #1e1e1e;
            --primary-color: #4dabf7; --secondary-color: #4dd0e1;
            --border-color: #444; --danger-color: #e57373; --success-color: #66bb6a;
            --player-red: #e57373; --player-gold: #90a4ae; --player-light-gray: #424242;
        }
        .sepia-mode {
            --bg-color: #f4e8c1; --text-color: #5b4636; --container-bg: #fbf0d9;
            --primary-color: #795548; --secondary-color: #8d6e63;
            --border-color: #d7ccc8; --danger-color: #a1887f; --success-color: #7cb342;
            --player-red: #8d6e63; --player-gold: #a1887f; --player-light-gray: #d7ccc8;
        }
        .high-contrast-mode {
            --bg-color: #000000;
            --text-color: #FFFFFF;
            --container-bg: #0a0a0a;
            --primary-color: #FFFF00;
            --secondary-color: #00FFFF;
            --border-color: #AAAAAA;
            --danger-color: #FF4136;
            --success-color: #01FF70;
            --player-red: #FF4136;
            --player-gold: #00FFFF;
            --player-light-gray: #333333;
        }
        .high-contrast-mode input, .high-contrast-mode select, .high-contrast-mode textarea {
             background-color: #111 !important; color: #FFF !important; border-color: #AAA !important;
        }
        .high-contrast-mode button.tool-btn,
        .high-contrast-mode .tool-btn-secondary:not(.danger-btn):not([style*="background-color: var(--success-color)"]) {
            color: #000000 !important;
        }
        .high-contrast-mode .tool-btn-secondary {
            background-color: var(--secondary-color) !important;
        }
        .high-contrast-mode button.tool-btn {
             background-color: var(--primary-color) !important;
        }
        .high-contrast-mode .danger-btn {
            background-color: var(--danger-color) !important; color: #FFF !important;
        }
         .high-contrast-mode button[style*="background-color: var(--success-color)"]{
            background-color: var(--success-color) !important; color: #000 !important;
        }
        .high-contrast-mode .theme-toggle {
            background-color: #222 !important; color: #FFF !important; border-color: #AAA !important;
        }
        .high-contrast-mode #clearUrlBtn { background-color: var(--danger-color) !important; color: #FFF !important; }
        .high-contrast-mode .header-buttons button {
            background-color: var(--secondary-color) !important; color: #000 !important;
        }
         .high-contrast-mode .header-buttons .save-btn.saved {
            background-color: var(--danger-color) !important; color: #FFF !important;
        }
        .high-contrast-mode .header-buttons button[title*="рд╢реЗрдпрд░ рдХрд░реЗрдВ"],
        .high-contrast-mode #shareLibArticleBtn {
             background-color: var(--success-color) !important; color: #000 !important;
        }
        .high-contrast-mode .original-view-btn,
        .high-contrast-mode #toggleOriginalViewLibBtn {
            background-color: var(--secondary-color) !important; color: #000 !important;
        }


        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; background-color: var(--bg-color); color: var(--text-color); line-height: var(--line-height-base); transition: background-color 0.3s, color 0.3s; margin: 0; padding-top: 5px; }
        #progress-bar { position: fixed; top: 0; left: 0; height: 5px; background: var(--primary-color); width: 0%; z-index: 9999; transition: width 0.1s; }
        .main-container { max-width: 800px; margin: 20px auto; padding: 20px; background-color: var(--container-bg); border-radius: 12px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); }
        h1, h2, h3 { color: var(--primary-color); }
        .tabs { border-bottom: 2px solid var(--border-color); overflow: hidden; margin-bottom: 20px; display: flex; flex-wrap: wrap; }
        .tab-link { background: transparent; border: none; cursor: pointer; padding: 14px 16px; font-size: 17px; color: var(--text-color); border-bottom: 3px solid transparent; }
        .tab-link.active { color: var(--primary-color); border-bottom-color: var(--primary-color); font-weight: bold; }
        input[type="url"], input[type="search"], input[type="text"], select, textarea { background-color: var(--container-bg); color: var(--text-color); border: 1px solid var(--border-color); width: 100%; padding: 12px; box-sizing: border-box; border-radius: 6px; font-size: 16px; margin-top: 10px; }
        textarea { min-height: 120px; line-height: 1.5; }
        button.tool-btn, .tool-btn-secondary { background-color: var(--primary-color); color: white; padding: 12px 20px; border: none; border-radius: 6px; cursor: pointer; font-size: 16px; margin-top: 15px; }
        .tool-btn-secondary { background-color: var(--secondary-color); margin-left: 10px; }
        .danger-btn { background-color: var(--danger-color) !important; }
        #clearUrlBtn { height: 46.4px; margin-top: 10px; font-size: 1.2em; background-color: var(--danger-color); color:white; border-radius:6px; border:none; cursor:pointer; padding: 0 12px;}
        .result-box { background-color: var(--bg-color); margin-top: 15px; padding: 15px; border-radius: 6px; font-size: var(--font-size-base); }
        .single-story { border-bottom: 2px dashed var(--border-color); padding-bottom: 20px; margin-bottom: 20px; }
        .single-story:last-child { border-bottom: none; margin-bottom: 0; }
        .single-story img { max-width: 100%; height: auto; display: block; margin: 15px auto; border-radius: 8px; }
        .story-header { display: flex; justify-content: space-between; align-items: center; gap: 10px; flex-wrap: wrap; }
        .header-buttons { display: flex; gap: 8px; flex-wrap: wrap; align-items: center;}
        .header-buttons button { background-color: var(--secondary-color); color: white; border: none; border-radius: 5px; padding: 6px 12px; font-size: 14px; cursor: pointer; }
        .header-buttons .save-btn.saved { background-color: var(--danger-color); }
        .original-view-btn { padding: 6px 10px !important; font-size: 14px !important;}
        .theme-toggle-container { position: fixed; top: 15px; right: 20px; z-index: 10001; display:flex; gap: 5px;}
        .theme-toggle { background: var(--container-bg); border: 1px solid var(--border-color); border-radius: 50%; width: 40px; height: 40px; cursor: pointer; font-size: 20px; display: flex; justify-content: center; align-items: center; }
        #ae_loading { margin-top: 15px; color: var(--primary-color); font-style: italic; text-align: center; }
        .library-item { display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid var(--border-color); }
        .library-item .item-title { flex-grow: 1; cursor: pointer; }
        .library-item .item-controls { display: flex; align-items: center; gap: 8px; }
        .library-item .read-status-toggle { cursor: pointer; font-size: 1.1em; padding: 0 5px; }
        .library-item.selected { background-color: var(--border-color); }
        .library-item .delete-btn { background-color: var(--danger-color); color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer; }
        .item-more-options-btn { background: transparent; border: none; color: var(--text-color); font-size: 1.5em; cursor: pointer; padding: 0 8px; line-height: 1; }
        .item-context-menu { position: absolute; background-color: var(--container-bg); border: 1px solid var(--border-color); border-radius: 6px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 1005; display: none; padding: 5px 0; font-size: 0.9em; }
        .item-context-menu button { background: none; border: none; color: var(--text-color); padding: 8px 16px; width: 100%; text-align: left; cursor: pointer; }
        .item-context-menu button:hover { background-color: var(--bg-color); }

        #lib-article-text-content { white-space: pre-wrap;  background-color: var(--bg-color);  padding: 15px;  border-radius: 6px;  max-height: 80vh;  overflow-y: auto; border: 1px solid var(--border-color); line-height: 1.7; }
        #lib-article-notes-container { margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--border-color); }
        #lib-article-notes-container h4 { margin-top: 0; }
        #lib-article-notes { width: 100%; min-height: 100px; box-sizing: border-box; margin-top: 0; }
        
        .reading-progress-container {
            position: sticky; top: 0; left: 0; width: 100%; height: 5px;
            background-color: var(--border-color); z-index: 100; display: none;
        }
        .reading-progress-bar {
            height: 100%; width: 0%; background-color: var(--primary-color);
            transition: width 0.1s ease-out;
        }
        #library-reading-progress-container { z-index: 1000; }
        .extractor-reading-progress-container { margin-bottom: 5px; }


        #lib-article-current-tags .tag-item { background-color: var(--secondary-color); color: white; padding: 3px 8px; border-radius: 4px; margin-right: 5px; margin-bottom: 5px; font-size: 0.9em; display: inline-block; }
        #lib-article-current-tags .tag-remove-btn { margin-left: 4px; border: none; background: transparent; color: white; cursor: pointer; font-weight: bold; }

        #audioPlayerContainer { display: none; flex-direction: column; gap: 10px; margin-top: 15px; padding: 15px; border-radius: 8px; background-color: var(--bg-color); border: 1px solid var(--border-color); }
        #audioPlayerContainer .visualizer-container { width: 100%; height: 60px; display: flex; align-items: center; justify-content: center; }
        #audioPlayerContainer .progress-container { display: flex; align-items: center; gap: 10px; font-size: 0.8em; color: var(--text-color); }
        #audioPlayerContainer input[type="range"] { -webkit-appearance: none; width: 100%; height: 4px; background: var(--player-light-gray); outline: none; margin: 0; cursor: pointer; background-image: linear-gradient(var(--player-red), var(--player-red)); background-size: 0% 100%; background-repeat: no-repeat; }
        #audioPlayerContainer input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 14px; height: 14px; background: var(--player-red); border-radius: 50%; cursor: pointer; }
        #audioPlayerContainer input[type="range"]::-moz-range-thumb { width: 14px; height: 14px; background: var(--player-red); border-radius: 50%; cursor: pointer; border: none; }
        #audioPlayerContainer .controls-container { display: flex; justify-content: space-around; align-items: center; }
        #audioPlayerContainer .controls-container button { background: none; border: none; cursor: pointer; font-size: 1.8em; color: var(--player-gold); padding: 5px; }
        #audioPlayerContainer .controls-container button.play-pause-btn { background-color: var(--player-red); color: white; width: 50px; height: 50px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 1.5em; }
        #audioPlayerContainer .controls-container button:disabled { opacity: 0.4; cursor: not-allowed; }
        #audioPlayerContainer .controls-container button.active { color: var(--player-red); }

        .queue-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); z-index: 10020; display: none; justify-content: center; align-items: center; opacity: 0; transition: opacity 0.3s ease; }
        .queue-modal-overlay.show { display: flex; opacity: 1; }
        .queue-modal-content { background-color: var(--container-bg); color: var(--text-color); padding: 20px; border-radius: 12px; width: 90%; max-width: 500px; max-height: 80vh; display: flex; flex-direction: column; }
        .queue-modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 15px; }
        .queue-modal-header h3 { margin: 0; color: var(--primary-color); }
        #queue-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
        .queue-item { display: flex; align-items: center; gap: 10px; padding: 10px; border-bottom: 1px solid var(--border-color); cursor: grab; user-select: none; }
        .queue-item:last-child { border-bottom: none; }
        .queue-item.playing { font-weight: bold; color: var(--primary-color); background-color: var(--bg-color); }
        .queue-item.dragging { opacity: 0.5; background: var(--border-color); }
        .queue-item-title { flex-grow: 1; cursor: pointer; }
        .queue-item .delete-btn { background-color: var(--danger-color); color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; }

        .link-list-item { display: flex; align-items: center; justify-content: space-between; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; margin-bottom: 10px; background-color: var(--bg-color); }
        .link-list-item .link-title { font-weight: bold; flex-grow: 1; margin-right: 15px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .link-list-item .link-actions button { padding: 6px 10px; font-size: 0.9em; margin-left: 8px; background-color: var(--secondary-color); color: white; border: none; border-radius: 5px; cursor: pointer; }
        .link-list-item .link-actions button:hover { opacity: 0.8; }

        .settings-modal-overlay, .collections-modal-overlay, .rule-modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.6); z-index: 10010;
            display: flex; justify-content: center; align-items: center;
            opacity: 0; transition: opacity 0.3s ease; pointer-events: none;
        }
        .settings-modal-overlay.show, .collections-modal-overlay.show, .rule-modal-overlay.show { opacity: 1; pointer-events: auto; }
        .settings-modal-content, .collections-modal-content, .rule-modal-content {
            background-color: var(--container-bg); color: var(--text-color);
            padding: 25px; border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            width: 90%; max-width: 600px; max-height: 90vh;
            display: flex; flex-direction: column;
            transform: scale(0.95); transition: transform 0.3s ease;
        }
        .settings-modal-overlay.show .settings-modal-content, 
        .collections-modal-overlay.show .collections-modal-content,
        .rule-modal-overlay.show .rule-modal-content { transform: scale(1); }
        .settings-modal-header, .collections-modal-header, .rule-modal-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); padding-bottom: 15px; margin-bottom: 20px; }
        .settings-modal-header h2, .collections-modal-header h2, .rule-modal-header h2 { margin: 0; color: var(--primary-color); }
        .settings-close-btn { background: transparent; border: none; font-size: 28px; font-weight: bold; color: var(--text-color); cursor: pointer; padding: 0 10px; }
        .settings-modal-body, .collections-modal-body, .rule-modal-body { overflow-y: auto; padding-right: 15px; margin-right: -15px; }
        .settings-modal-body fieldset { border: 1px solid var(--border-color); border-radius: 8px; padding: 15px; margin-bottom: 20px; }
        .settings-modal-body legend { font-weight: bold; color: var(--primary-color); padding: 0 10px; }
        .setting-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px; }
        .setting-item:last-child { margin-bottom: 0; }
        .setting-item label { flex-shrink: 0; }
        .setting-control { display: flex; gap: 15px; align-items: center; flex-grow: 1; justify-content: flex-end; flex-wrap: wrap; }
        .setting-control button, .setting-control select { background-color: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 5px; padding: 8px 12px; cursor: pointer; }
        .setting-control input[type="radio"] + label { cursor: pointer; }
        .setting-control .danger-btn { background-color: var(--danger-color); color: white; }
        .setting-control .range-control { display: flex; align-items: center; gap: 10px; }
        .danger-zone { border-color: var(--danger-color); }
        .danger-zone legend { color: var(--danger-color); }
        .settings-modal-footer, .collections-modal-footer, .rule-modal-footer { border-top: 1px solid var(--border-color); padding-top: 20px; margin-top: 10px; text-align: right; }
        .rule-builder-item { margin-bottom: 10px; }
        .rule-builder-item select, .rule-builder-item input { margin-top: 0; font-size: 0.9em; }

        .fallback-share-modal {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: var(--container-bg); color: var(--text-color);
            padding: 20px; border-radius: 12px; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            z-index: 10050; width: 90%; max-width: 400px;
        }
        .fallback-share-modal textarea { width: calc(100% - 20px); min-height: 100px; margin-bottom: 10px; padding: 10px; background-color: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 6px; }

        #toast-container { position: fixed; bottom: 20px; right: 20px; z-index: 10060; display: flex; flex-direction: column; gap: 10px; }
        .toast-notification { background-color: var(--primary-color); color: white; padding: 15px 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); opacity: 0; transform: translateX(100%); transition: opacity 0.3s ease, transform 0.3s ease; font-size: 0.9em; }
        .toast-notification.show { opacity: 1; transform: translateX(0); }
        .toast-notification.success { background-color: var(--success-color); }
        .toast-notification.error { background-color: var(--danger-color); }
        .toast-notification.warning { background-color: var(--player-gold); color: var(--text-color); }
        .toast-actions button { background: rgba(255,255,255,0.2); color: white; border: none; padding: 5px 10px; margin-left: 10px; border-radius: 4px; cursor: pointer; }

        #backToTopBtn { display: none; position: fixed; bottom: 20px; left: 20px; z-index: 99; border: none; outline: none; background-color: var(--primary-color); color: white; cursor: pointer; padding: 10px 15px; border-radius: 50%; font-size: 18px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        #backToTopBtn:hover { background-color: var(--secondary-color); }

        .library-playlist-controls { margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
        .library-playlist-controls button { margin-left: 0 !important; }
        #libraryBatchControls { display: none; gap: 10px; margin-top: 10px; padding: 10px; background-color: var(--bg-color); border-radius: 6px; border: 1px solid var(--border-color); }
        #libraryBatchControls button { margin-top: 0; margin-left: 0; font-size: 0.9em; padding: 8px 12px; }
        #libVoiceSelectorContainer, #voiceSelectorContainerSetting { display: flex; align-items: center; gap: 10px;}
        .article-body-content img { max-width: 100%; height: auto; display: block; margin: 15px auto; border-radius: 8px; }
        hr { border: 0; height: 1px; background-color: var(--border-color); margin: 20px 0; }
        .library-item input[type="checkbox"].playlist-checkbox { margin-right: 10px; transform: scale(1.2); cursor:pointer; }
        .bookmark-item { display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid var(--border-color); }
        .bookmark-item:last-child { border-bottom: none; }
        .bookmark-item .item-title { flex-grow: 1; cursor: pointer; }
        .bookmark-item .delete-btn { background-color: var(--danger-color); color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer; font-size: 0.9em; }
        #bookmark-controls { margin-bottom:15px; display:flex; flex-wrap:wrap; gap:10px; align-items:flex-end; }
        #bookmark-controls input, #bookmark-controls select { margin-top:0; }
        #bookmark-list-container { margin-top:15px; }

        #rss-feed-controls { display:flex; gap:10px; align-items:flex-end; margin-bottom:15px; flex-wrap: wrap;}
        #rss-feed-controls input {flex-grow:1; margin-top:0;}
        #rss-feed-controls button {margin-top:0; padding:12px 15px; font-size:0.9em;}
        #rss-opml-controls { display: flex; gap: 10px; margin-top: 10px; }
        #rss-opml-controls button { font-size: 0.9em; padding: 8px 12px; margin-top: 0; margin-left: 0; }

        #subscribedFeedsList ul { list-style: none; padding-left: 0; }
        #subscribedFeedsList li { margin-bottom: 8px; padding: 8px; background-color: var(--bg-color); border-radius: 4px; display:flex; justify-content:space-between; align-items:center;}
        #subscribedFeedsList li a { color: var(--primary-color); text-decoration: none; font-weight: bold; flex-grow:1;}
        #subscribedFeedsList li a:hover { text-decoration: underline; }
        #rssArticlesContainer { border-top: 1px solid var(--border-color); margin-top:20px; padding-top:15px;}
        .rss-article-item {
            display: flex; justify-content: space-between; align-items: center; padding: 10px;
            border-bottom: 1px solid var(--border-color);
        }
        .rss-article-item .item-title { cursor:pointer; flex-grow: 1; }
        .rss-article-item:last-child { border-bottom: none; }
        .rss-article-item:hover { background-color: var(--bg-color); }
        .rss-article-item small { color: var(--text-color); opacity: 0.7; font-size:0.8em;}
        
        #stats-container .stat-card { background-color: var(--bg-color); padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 1px solid var(--border-color); }
        #stats-container .stat-card h3 { margin-top: 0; }
        #stats-container .stat-card ul { padding-left: 20px; }

        /* Focus Mode Styles */
        .focus-mode-active .main-container > h1,
        .focus-mode-active #googleSearchContainer,
        .focus-mode-active #internalNavHistoryContainer,
        .focus-mode-active .tabs,
        .focus-mode-active #ArticleExtractor > p,
        .focus-mode-active #ArticleExtractor > div:not(.result-box):not(#ae_loading),
        .focus-mode-active #ArticleExtractor > button:not([onclick*="ae_startExtraction"]):not([onclick*="clearResults"]),
        .focus-mode-active #MyLibrary > h2,
        .focus-mode-active #MyLibrary > .library-controls,
        .focus-mode-active #MyLibrary > .library-playlist-controls,
        .focus-mode-active #library-list-container,
        .focus-mode-active #libraryBatchControls,
        .focus-mode-active #Bookmarks > h2,
        .focus-mode-active #Bookmarks > #bookmark-controls,
        .focus-mode-active #Bookmarks > #bookmark-list-container,
        .focus-mode-active #RSSFeeds > h2,
        .focus-mode-active #RSSFeeds > #rss-feed-controls,
        .focus-mode-active #RSSFeeds > #rss-opml-controls,
        .focus-mode-active #RSSFeeds > #subscribedFeedsListContainer,
        .focus-mode-active #Statistics > h2,
        .focus-mode-active #backToTopBtn,
        .focus-mode-active #audioPlayerContainer .progress-container,
        .focus-mode-active #audioPlayerContainer .controls-container button:not(.play-pause-btn),
        .focus-mode-active #sleep-timer-controls,
        .focus-mode-active #lib-article-tags-container,
        .focus-mode-active #lib-article-notes-container,
        .focus-mode-active #lib-article-original-url,
        .focus-mode-active #library-article-view > div:first-of-type,
        .focus-mode-active #autoScrollControls,
        .focus-mode-active .reading-progress-container
         {
            display: none !important;
        }
        .focus-mode-active .theme-toggle-container {
            display: flex !important;
        }
        .focus-mode-active #focusModeToggleBtn {
            display: flex !important;
        }
        .focus-mode-active .main-container {
            max-width: 100%;
            margin-top: 5px;
            padding: 5px;
            box-shadow: none;
            border-radius: 0;
        }
        .focus-mode-active #ae_result .single-story,
        .focus-mode-active #library-article-view {
            margin: 0 auto;
            padding: 10px;
            max-width: 800px;
            border-bottom: none !important;
        }
        .focus-mode-active #ae_result .single-story hr {
            display:none !important;
        }
        .focus-mode-active #lib-article-text-content {
            max-height: calc(100vh - 120px);
            border: none;
            padding: 5px;
        }
        .focus-mode-active #audioPlayerContainer {
            position: sticky;
            bottom: 0;
            background-color: var(--container-bg);
            border-top: 1px solid var(--border-color);
            border-radius: 0;
            padding: 10px;
            margin-top: 0;
        }
        .focus-mode-active #audioPlayerContainer .visualizer-container { height: 40px; }
    </style>
</head>
<body>
    <div id="progress-bar"></div>
    <div class="theme-toggle-container">
        <button class="theme-toggle" onclick="toggleTheme('light')" title="рд▓рд╛рдЗрдЯ рдореЛрдб">тШАя╕П</button>
        <button class="theme-toggle" onclick="toggleTheme('dark')" title="рдбрд╛рд░реНрдХ рдореЛрдб">ЁЯМУ</button>
        <button class="theme-toggle" onclick="toggleTheme('sepia')" title="рд╕реЗрдкрд┐рдпрд╛ рдореЛрдб">ЁЯУЬ</button>
        <button class="theme-toggle" onclick="toggleTheme('high-contrast')" title="рдЙрдЪреНрдЪ рдХрдВрдЯреНрд░рд╛рд╕реНрдЯ рдореЛрдб">ЁЯСБя╕ПтАНЁЯЧия╕П</button>
        <button id="focusModeToggleBtn" class="theme-toggle" onclick="toggleFocusMode()" title="рдлрд╝реЛрдХрд╕ рдореЛрдб рдЯреЙрдЧрд▓ рдХрд░реЗрдВ">ЁЯзШ</button>
        <button class="theme-toggle" onclick="openSettingsModal()" title="рд╕реЗрдЯрд┐рдВрдЧреНрд╕">тЪЩя╕П</button>
    </div>
    <div class="main-container">
        <h1>рдЖрд░реНрдЯрд┐рдХрд▓ рд░реАрдбрд░ рдкреНрд░реЛ</h1>
        <div id="googleSearchContainer" style="margin-bottom: 15px; display: flex; gap: 5px;"><input type="search" id="googleSearchQuery" placeholder="рдЧреВрдЧрд▓ рдкрд░ рдЦреЛрдЬреЗрдВ..." style="flex-grow: 1; margin-top:0;"><button onclick="performGoogleSearch()" class="tool-btn" style="margin-top:0; padding: 12px 15px;" title="рдЦреЛрдЬреЗрдВ">ЁЯФН</button></div>
        <div id="internalNavHistoryContainer" style="display: none; justify-content:space-between; margin-bottom:10px;"><button id="historyBackBtn" onclick="navigateHistory(-1)" disabled>тмЕя╕П рдкрд┐рдЫрд▓рд╛</button><button id="historyForwardBtn" onclick="navigateHistory(1)" disabled>тЮбя╕П рдЕрдЧрд▓рд╛</button></div>
        <div class="tabs">
            <button class="tab-link active" onclick="openTool(event, 'ArticleExtractor')">рдЖрд░реНрдЯрд┐рдХрд▓ рдирд┐рдХрд╛рд▓реЗрдВ</button>
            <button class="tab-link" onclick="openTool(event, 'MyLibrary')">рдореЗрд░реА рд▓рд╛рдЗрдмреНрд░реЗрд░реА <span id="library-count">(0)</span></button>
            <button class="tab-link" onclick="openTool(event, 'Bookmarks')">рдмреБрдХрдорд╛рд░реНрдХ <span id="bookmark-count">(0)</span></button>
            <button class="tab-link" onclick="openTool(event, 'RSSFeeds')">RSS рдлрд╝реАрдбреНрд╕ <span id="rss-feed-count">(0)</span></button>
            <button class="tab-link" onclick="openTool(event, 'Statistics')">рдЖрдБрдХрдбрд╝реЗ</button>
        </div>

        <div id="ArticleExtractor" class="tool-content" style="display:block;">
            <p>рдХрд┐рд╕реА рднреА рдЖрд░реНрдЯрд┐рдХрд▓ рдХрд╛ рд▓рд┐рдВрдХ, рдХреИрдЯреЗрдЧрд░реА рдкреЗрдЬ рдпрд╛ рд╡реЗрдмрд╕рд╛рдЗрдЯ рдХрд╛ рд╣реЛрдордкреЗрдЬ рд▓рд┐рдВрдХ рдпрд╣рд╛рдБ рдбрд╛рд▓реЗрдВред</p>
            <div style="display: flex; align-items: center; gap: 5px;">
                <input type="url" id="articleUrl" placeholder="https://example.com/" style="flex-grow: 1; margin-top:0;">
                <button id="clearUrlBtn" onclick="clearUrlInput()" title="URL рд╕рд╛рдлрд╝ рдХрд░реЗрдВ">тЬЧ</button>
            </div>
            <div style="margin-top: 10px; margin-bottom: 5px; display: flex; flex-wrap: wrap; align-items: center; gap: 15px;">
                <div><input type="checkbox" id="crawlSiteToggle" name="crawlSiteToggle" checked onchange="toggleDepthSelector()"><label for="crawlSiteToggle" style="font-size: 0.9em; cursor:pointer;">рдЗрд╕ URL рд╕реЗ рдЬреБрдбрд╝реЗ рдЕрдиреНрдп рдЖрд░реНрдЯрд┐рдХрд▓ рднреА рдЦреЛрдЬреЗрдВ</label></div>
                <div id="depthSelectorContainer" style="display: inline-block;"><label for="crawlDepth" style="font-size: 0.9em;">рдЦреЛрдЬ рдХреА рдЧрд╣рд░рд╛рдИ:</label><select id="crawlDepth" name="crawlDepth" style="font-size: 0.9em; padding: 5px;"><option value="0">рдХреЗрд╡рд▓ рдпрд╣ рдкреЗрдЬ (рдпрд╛ рдЗрд╕ рдкреЗрдЬ рдХреЗ рд▓рд┐рдВрдХ)</option><option value="1" selected>1 рд╕реНрддрд░ рдЧрд╣рд░рд╛</option><option value="2">2 рд╕реНрддрд░ рдЧрд╣рд░рд╛</option><option value="3">3 рд╕реНрддрд░ рдЧрд╣рд░рд╛ (рдзреАрдорд╛ рд╣реЛ рд╕рдХрддрд╛ рд╣реИ)</option></select></div>
            </div>
            <div style="margin-top: 15px; margin-bottom: 5px;">
                <input type="search" id="extractorSearch" placeholder="рд╡рд░реНрддрдорд╛рди рдЖрд░реНрдЯрд┐рдХрд▓реНрд╕ рдореЗрдВ рдЦреЛрдЬреЗрдВ..." oninput="filterExtractedArticles()" style="width: calc(100% - 145px); margin-right: 10px; margin-top:0;">
                <button onclick="clearExtractorSearch()" class="tool-btn-secondary" style="padding: 10px 15px; margin-top: 0; font-size:0.9em;">рдЦреЛрдЬ рд╕рд╛рдлрд╝ рдХрд░реЗрдВ</button>
            </div>
            <button class="tool-btn" onclick="ae_startExtraction()">рдЖрд░реНрдЯрд┐рдХрд▓ рдирд┐рдХрд╛рд▓реЗрдВ</button>
            <button id="toggleCrawlBtn" class="tool-btn-secondary" onclick="toggleCrawling()" style="display: none;">тП╣я╕П рдХреНрд░реЙрд▓рд┐рдВрдЧ рд░реЛрдХреЗрдВ</button>
            <button class="tool-btn-secondary" onclick="clearResults()">рдкрд░рд┐рдгрд╛рдо рд╕рд╛рдлрд╝ рдХрд░реЗрдВ</button>
            <button id="playAllExtractedBtn" class="tool-btn-secondary" onclick="playAllExtractedArticles()" style="display: none; background-color: var(--success-color); margin-left:10px; margin-top:15px;">тЦ╢я╕П рд╕рднреА рдкреНрд▓реЗ рдХрд░реЗрдВ</button>
            <div id="ae_loading" style="display:none;"></div>
            <div class="result-box" id="ae_result"></div>
        </div>

        <div id="MyLibrary" class="tool-content" style="display:none;">
            <h2>рд╕реЗрд╡ рдХрд┐рдП рдЧрдП рдЖрд░реНрдЯрд┐рдХрд▓</h2>
            <div class="library-controls">
                <input type="search" id="librarySearch" placeholder="рд╢реАрд░реНрд╖рдХ рдпрд╛ рдХрдВрдЯреЗрдВрдЯ рд╕реЗ рдЦреЛрдЬреЗрдВ..." oninput="loadLibrary()">
                <select id="librarySort" onchange="loadLibrary()">
                    <option value="date_desc">рд╕рдмрд╕реЗ рдирдпрд╛ рдкрд╣рд▓реЗ</option><option value="date_asc">рд╕рдмрд╕реЗ рдкреБрд░рд╛рдирд╛ рдкрд╣рд▓реЗ</option>
                    <option value="title_asc">рдЯрд╛рдЗрдЯрд▓ (A-Z)</option><option value="title_desc">рдЯрд╛рдЗрдЯрд▓ (Z-A)</option>
                </select>
                <div id="libraryCollectionFilterContainer" style="display:inline-block; margin-left:10px;"><label for="libraryCollectionFilter" style="font-size:0.9em;">рдХрд▓реЗрдХреНрд╢рди:</label><select id="libraryCollectionFilter" onchange="loadLibrary()" style="font-size:0.9em; padding:5px; width:auto; margin-top:0;"></select> <button onclick="openCollectionsModal()" title="рдХрд▓реЗрдХреНрд╢рди рдкреНрд░рдмрдВрдзрд┐рдд рдХрд░реЗрдВ" style="padding: 4px 6px; font-size: 0.8em; margin-left: 2px; vertical-align: middle;">тЪЩя╕П</button></div>
                <div id="libraryTagFilterContainer" style="display:inline-block; margin-left:10px;"><label for="libraryTagFilter" style="font-size:0.9em;">рдЯреИрдЧ рдлрд╝рд┐рд▓реНрдЯрд░:</label><select id="libraryTagFilter" onchange="loadLibrary()" style="font-size:0.9em; padding:5px; width:auto; margin-top:0;"><option value="">рд╕рднреА рдЯреИрдЧ</option></select></div>
                <div id="libraryReadStatusFilterContainer" style="display:inline-block; margin-left:10px;"><label for="libraryReadStatusFilter" style="font-size:0.9em;">рд╕реНрдерд┐рддрд┐:</label><select id="libraryReadStatusFilter" onchange="loadLibrary()" style="font-size:0.9em; padding:5px; width:auto; margin-top:0;"><option value="all">рд╕рднреА</option><option value="read">рдкрдврд╝рд╛ рд╣реБрдЖ</option><option value="unread">рдЕрдкрдард┐рдд</option></select></div>
                <button id="clearLibraryFiltersBtn" class="tool-btn-secondary" onclick="clearLibraryFilters()" style="margin-top:0; margin-left: 10px; font-size:0.9em; padding:8px 12px; display:none;">рдлрд╝рд┐рд▓реНрдЯрд░ рд╕рд╛рдлрд╝ рдХрд░реЗрдВ</button>
            </div>
            <div class="library-playlist-controls">
                <button id="playSelectedBtn" onclick="playSelectedLibraryItems()" class="tool-btn-secondary" style="margin-top:10px; margin-left:0; display:none; background-color: var(--success-color);">рдЪрдпрдирд┐рдд рдЪрд▓рд╛рдПрдВ</button>
                <button id="createSelectedMp3Btn" onclick="createSelectedMp3()" class="tool-btn-secondary" style="margin-top:10px; margin-left:10px; display:none;">рдЪрдпрдирд┐рдд рдХрд╛ MP3 рдмрдирд╛рдПрдВ</button>
                <button id="viewQueueBtn" onclick="openQueueModal()" class="tool-btn-secondary" style="margin-top:10px; margin-left:10px; display:none;">рдХреНрдпреВ рджреЗрдЦреЗрдВ (<span id="queue-count">0</span>)</button>
                <div style="margin-top:10px; margin-left:10px;"><input type="checkbox" id="autoPlayNextToggle" onchange="handleAutoPlayToggle(this.checked)"><label for="autoPlayNextToggle" style="font-size: 0.9em; cursor:pointer;">рдЕрдЧрд▓рд╛ рдСрдЯреЛ-рдкреНрд▓реЗ рдХрд░реЗрдВ</label></div>
            </div>
            <div id="libraryBatchControls">
                <button onclick="handleBatchDelete()">рдЪрдпрдирд┐рдд рдХреЛ рдбрд┐рд▓реАрдЯ рдХрд░реЗрдВ</button>
                <button onclick="handleBatchTag()">рдЪрдпрдирд┐рдд рдХреЛ рдЯреИрдЧ рдХрд░реЗрдВ</button>
                <button onclick="handleBatchMarkAsRead(true)">рдкрдврд╝рд╛ рдЪрд┐рд╣реНрдирд┐рдд рдХрд░реЗрдВ</button>
                <button onclick="handleBatchMarkAsRead(false)">рдЕрдкрдард┐рдд рдЪрд┐рд╣реНрдирд┐рдд рдХрд░реЗрдВ</button>
            </div>
            <div class="library-controls" style="margin-top:10px;">
                <button onclick="exportLibrary()" class="tool-btn-secondary" style="margin-top:0; margin-left:0; font-size:0.9em; padding:8px 12px;">рд▓рд╛рдЗрдмреНрд░реЗрд░реА рдПрдХреНрд╕рдкреЛрд░реНрдЯ рдХрд░реЗрдВ</button>
                <input type="file" id="importLibraryFile" accept=".json" onchange="importLibraryHandler(event)" style="display:none;">
                <button onclick="document.getElementById('importLibraryFile').click()" class="tool-btn-secondary" style="margin-top:0; font-size:0.9em; padding:8px 12px;">рд▓рд╛рдЗрдмреНрд░реЗрд░реА рдЗрдВрдкреЛрд░реНрдЯ рдХрд░реЗрдВ</button>
            </div>
            <div id="library-content-wrapper" style="margin-top:15px;">
                <div id="library-list-container">
                    <div style="padding: 5px 10px;">
                        <input type="checkbox" id="selectAllCheckbox" onchange="toggleSelectAll(this.checked)">
                        <label for="selectAllCheckbox" style="cursor:pointer; font-size: 0.9em;">рд╕рднреА рдЪреБрдиреЗрдВ</label>
                    </div>
                    <div id="library-list"></div>
                </div>
                <div id="library-article-view" style="display: none;">
                    <div id="library-reading-progress-container" class="reading-progress-container">
                        <div id="library-reading-progress-bar" class="reading-progress-bar"></div>
                    </div>
                    <h3 id="lib-article-title"></h3>
                    <p style="margin-top:0; margin-bottom: 5px;"><small>рдореВрд▓ URL: <a id="lib-article-original-url" href="#" target="_blank" rel="noopener noreferrer"></a></small></p>
                    <div style="margin-bottom:15px; margin-top:5px; display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
                        <button onclick="copyLibraryArticleText()" class="tool-btn-secondary" style="padding: 8px 12px; font-size: 0.9em; margin-left:0; margin-top:0;">рдкреВрд░рд╛ рдЯреЗрдХреНрд╕реНрдЯ рдХреЙрдкреА рдХрд░реЗрдВ</button>
                        <button id="shareLibArticleBtn" class="tool-btn-secondary" style="padding: 8px 12px; font-size: 0.9em; background-color: var(--success-color); margin-top:0;">рд╢реЗрдпрд░ рдХрд░реЗрдВ</button>
                        <button onclick="toggleOriginalWebViewForLibrary()" id="toggleOriginalViewLibBtn" class="tool-btn-secondary original-view-btn" style="padding: 8px 12px; font-size: 0.9em; margin-left:0; margin-top:0;">ЁЯМР рд╡реЗрдм рд╡реНрдпреВ рджрд┐рдЦрд╛рдПрдВ</button>
                        <div style="display:inline-block;"><label for="libArticleCollection" style="font-size:0.9em;">рдХрд▓реЗрдХреНрд╢рди: </label><select id="libArticleCollection" onchange="assignArticleToCollection(this.value)" style="font-size:0.9em; padding:5px; margin-top:0; width: auto;"></select></div>
                        <div style="margin-left:auto;"><label style="font-size:0.9em;">рдлрд╝реЙрдиреНрдЯ: </label><button onclick="adjustFontSizeSetting('library', -1)" title="рдлрд╝реЙрдиреНрдЯ рдШрдЯрд╛рдПрдВ" style="padding:5px 8px; font-size:0.8em;">A-</button><button onclick="adjustFontSizeSetting('library', 1)" title="рдлрд╝реЙрдиреНрдЯ рдмрдврд╝рд╛рдПрдВ" style="padding:5px 8px; font-size:0.8em;">A+</button></div>
                    </div>
                     <div id="autoScrollControls" style="margin-top:10px; margin-bottom:10px; padding:10px; border:1px solid var(--border-color); border-radius: 6px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                        <span style="font-weight:bold;">рдСрдЯреЛ-рд╕реНрдХреНрд░реЙрд▓:</span>
                        <button id="autoScrollPlayPauseBtn" onclick="toggleAutoScroll()" class="tool-btn-secondary" style="margin-left:0; margin-top:0; padding: 6px 10px; font-size:0.9em;">тЦ╢я╕П рд╢реБрд░реВ рдХрд░реЗрдВ</button>
                        <button onclick="changeAutoScrollSpeed(-20)" class="tool-btn-secondary" style="margin-left:0; margin-top:0; padding: 6px 10px; font-size:0.9em;">рдзреАрдорд╛ ЁЯРв</button>
                        <button onclick="changeAutoScrollSpeed(20)" class="tool-btn-secondary" style="margin-left:0; margin-top:0; padding: 6px 10px; font-size:0.9em;">рддреЗрдЬрд╝ ЁЯРЗ</button>
                        <span id="autoScrollSpeedDisplay" style="font-size:0.9em; margin-left:auto;">рдЧрддрд┐: 50</span>
                    </div>
                    <div id="audioPlayerContainer">
                        <div class="visualizer-container"><canvas id="audioVisualizer" width="300" height="60"></canvas></div>
                        <div class="progress-container"><span class="current-time">0:00</span><input type="range" class="progress-bar" value="0" min="0" max="100" step="0.1"><span class="total-time">0:00</span></div>
                        <div class="controls-container"><button class="shuffle-btn" title="рд╢рдлрд▓">ЁЯФА</button><button class="skip-btn prev-btn" title="рдкрд┐рдЫрд▓рд╛">тПоя╕П</button><button class="play-pause-btn" title="рдкреНрд▓реЗ/рдкреЙрдЬрд╝">тЦ╢я╕П</button><button class="skip-btn next-btn" title="рдЕрдЧрд▓рд╛">тПня╕П</button><button class="repeat-btn" title="рд░рд┐рдкреАрдЯ">ЁЯФБ</button></div>
                    </div>
                    <div id="sleep-timer-controls" style="margin-top: 15px; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; display: flex; flex-wrap: wrap; align-items: center; gap: 10px;">
                        <label for="sleepTimerSelect" style="font-weight: bold; color: var(--primary-color);">тП▓я╕П рд╕реНрд▓реАрдк рдЯрд╛рдЗрдорд░:</label>
                        <select id="sleepTimerSelect" onchange="setSleepTimer(this.value)" style="padding: 5px 8px; font-size: 0.9em; background-color: var(--bg-color); color: var(--text-color); border:1px solid var(--border-color); border-radius:4px; cursor:pointer; margin-top:0;">
                            <option value="0">рдмрдВрдж</option><option value="5">5 рдорд┐рдирдЯ</option><option value="15">15 рдорд┐рдирдЯ</option>
                            <option value="30">30 рдорд┐рдирдЯ</option><option value="60">60 рдорд┐рдирдЯ</option><option value="-1">рдЗрд╕ рдЖрд░реНрдЯрд┐рдХрд▓ рдХреЗ рдЕрдВрдд рдореЗрдВ</option>
                        </select>
                        <button id="cancelSleepTimerBtn" onclick="cancelSleepTimer()" style="display: none; background-color: var(--danger-color); color: white; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-size: 0.9em; margin-top:0;">рд░рджреНрдж рдХрд░реЗрдВ</button>
                        <span id="sleepTimerDisplay" style="margin-left: auto; font-size: 0.9em; font-style: italic;"></span>
                    </div>

                    <div id="lib-article-text-content"></div>
                    <div id="lib-article-webview-container" style="display:none;">
                        <iframe id="lib-article-iframe" src="about:blank" sandbox="allow-scripts allow-same-origin allow-popups allow-forms"></iframe>
                    </div>

                    <div id="lib-article-tags-container" style="margin-top: 15px;">
                        <h4>рдЯреИрдЧреНрд╕:</h4><div id="lib-article-current-tags" style="margin-bottom:10px;"></div>
                        <div style="display: flex; gap: 5px; align-items:center;">
                            <input type="text" id="lib-new-tag-input" placeholder="рдирдпрд╛ рдЯреИрдЧ рдЬреЛрдбрд╝реЗрдВ" style="flex-grow:1; margin-top:0; font-size:0.9em; padding:8px;">
                            <button onclick="addTagToCurrentLibraryArticle()" class="tool-btn-secondary" style="margin-top:0;padding: 8px 12px; font-size: 0.9em;">рдЯреИрдЧ рдЬреЛрдбрд╝реЗрдВ</button>
                        </div>
                    </div>
                    <div id="lib-article-notes-container" style="display: none;">
                        <h4>рдореЗрд░реЗ рдиреЛрдЯреНрд╕</h4>
                        <textarea id="lib-article-notes" placeholder="рдЗрд╕ рдЖрд░реНрдЯрд┐рдХрд▓ рдХреЗ рдмрд╛рд░реЗ рдореЗрдВ рдЕрдкрдиреЗ рд╡рд┐рдЪрд╛рд░ рдпрд╛ рд╕рд╛рд░рд╛рдВрд╢ рдпрд╣рд╛рдБ рд▓рд┐рдЦреЗрдВ..."></textarea>
                    </div>
                </div>
            </div>
        </div>

        <div id="Bookmarks" class="tool-content" style="display:none;">
            <h2>рдмреБрдХрдорд╛рд░реНрдХ</h2>
            <div id="bookmark-controls">
                <input type="text" id="bookmarkName" placeholder="рдирд╛рдо (рд╡реИрдХрд▓реНрдкрд┐рдХ)" style="flex:1;">
                <input type="url" id="bookmarkUrl" placeholder="https://example.com/" required style="flex:2;">
                <select id="bookmarkAssignFolder" title="рдлрд╝реЛрд▓реНрдбрд░ рдЪреБрдиреЗрдВ" style="flex:1;"></select>
                <button class="tool-btn" onclick="addBookmark()" style="padding:10px 15px; font-size:0.9em; margin-top:0;">рдмреБрдХрдорд╛рд░реНрдХ рдЬреЛрдбрд╝реЗрдВ</button>
            </div>
             <div id="bookmark-controls" style="margin-top:5px;">
                <input type="text" id="newBookmarkFolderName" placeholder="рдирдпрд╛ рдлрд╝реЛрд▓реНрдбрд░ рдирд╛рдо" style="flex:1;">
                <button class="tool-btn-secondary" onclick="createBookmarkFolder()" style="padding:10px 15px; font-size:0.9em; margin-left:0; margin-top:0;">рдлрд╝реЛрд▓реНрдбрд░ рдмрдирд╛рдПрдБ</button>
                <select id="bookmarkFolderFilter" onchange="loadBookmarks()" title="рдлрд╝реЛрд▓реНрдбрд░ рджреНрд╡рд╛рд░рд╛ рдлрд╝рд┐рд▓реНрдЯрд░ рдХрд░реЗрдВ" style="flex:1; margin-left:auto;"></select>
            </div>
            <div id="bookmark-list-container">
                <div id="bookmark-list"></div>
            </div>
        </div>

        <div id="RSSFeeds" class="tool-content" style="display:none;">
            <h2>RSS рдлрд╝реАрдбреНрд╕</h2>
            <div id="rss-feed-controls">
                <input type="url" id="rssFeedUrlInput" placeholder="рд╡реЗрдмрд╕рд╛рдЗрдЯ URL рдпрд╛ RSS рдлрд╝реАрдб URL рдбрд╛рд▓реЗрдВ">
                <button class="tool-btn" onclick="addRssFeed()">рдлрд╝реАрдб рдЬреЛрдбрд╝реЗрдВ</button>
                <button id="refreshAllRssFeedsBtn" class="tool-btn-secondary" onclick="refreshAllRssFeeds()" style="margin-left:10px;">ЁЯФД рд╕рднреА рд░рд┐рдлреНрд░реЗрд╢ рдХрд░реЗрдВ</button>
            </div>
            <div id="rss-opml-controls">
                <button class="tool-btn-secondary" onclick="exportOpml()">OPML рдПрдХреНрд╕рдкреЛрд░реНрдЯ рдХрд░реЗрдВ</button>
                <input type="file" id="opmlImportFile" accept=".opml,.xml" onchange="importOpml(event)" style="display:none;">
                <button class="tool-btn-secondary" onclick="document.getElementById('opmlImportFile').click()">OPML рдЗрдВрдкреЛрд░реНрдЯ рдХрд░реЗрдВ</button>
            </div>
            <div id="subscribedFeedsListContainer" style="margin-top:15px;">
                 <div id="subscribedFeedsList"></div>
            </div>
            <div id="rssArticlesContainer" style="margin-top:15px;">
                <h3 id="rssFeedTitleDisplay"></h3>
                <div id="rssArticlesList"></div>
            </div>
        </div>
        
        <div id="Statistics" class="tool-content" style="display:none;">
            <h2>рдЖрдкрдХреЗ рд░реАрдбрд┐рдВрдЧ рдЖрдБрдХрдбрд╝реЗ</h2>
            <div id="stats-container"></div>
        </div>

    </div>
    <button id="backToTopBtn" onclick="scrollToTop()" title="рдКрдкрд░ рдЬрд╛рдПрдВ">тмЖя╕П</button>
    <div id="toast-container"></div>

    <div id="queueModal" class="queue-modal-overlay">
        <div class="queue-modal-content">
            <div class="queue-modal-header"><h3>рдкреНрд▓реЗрдмреИрдХ рдХреНрдпреВ</h3><button class="settings-close-btn" onclick="closeQueueModal()">├Ч</button></div>
            <ul id="queue-list"></ul>
            <div class="queue-modal-footer" style="text-align:right; margin-top:15px; border-top: 1px solid var(--border-color); padding-top:15px;">
                <button class="tool-btn-secondary danger-btn" style="margin-left:0; margin-top:0;" onclick="clearQueue()">рдХреНрдпреВ рд╕рд╛рдлрд╝ рдХрд░реЗрдВ</button>
            </div>
        </div>
    </div>

    <div id="settingsModal" class="settings-modal-overlay">
        <div class="settings-modal-content">
            <div class="settings-modal-header">
                <h2>рд╕реЗрдЯрд┐рдВрдЧреНрд╕</h2>
                <button class="settings-close-btn" onclick="closeSettingsModal()">├Ч</button>
            </div>
            <div class="settings-modal-body">
                <fieldset>
                    <legend>рдереАрдо</legend>
                    <div class="setting-item">
                        <label>рд░рдВрдЧ рдпреЛрдЬрдирд╛ рдЪреБрдиреЗрдВ:</label>
                        <div class="setting-control">
                            <input type="radio" id="theme_light" name="theme_setting" value="light"><label for="theme_light">тШАя╕П рд▓рд╛рдЗрдЯ</label>
                            <input type="radio" id="theme_dark" name="theme_setting" value="dark"><label for="theme_dark">ЁЯМУ рдбрд╛рд░реНрдХ</label>
                            <input type="radio" id="theme_sepia" name="theme_setting" value="sepia"><label for="theme_sepia">ЁЯУЬ рд╕реЗрдкрд┐рдпрд╛</label>
                            <input type="radio" id="theme_high_contrast" name="theme_setting" value="high-contrast"><label for="theme_high_contrast">ЁЯСБя╕ПтАНЁЯЧия╕П рдЙрдЪреНрдЪ рдХрдВрдЯреНрд░рд╛рд╕реНрдЯ</label>
                        </div>
                    </div>
                </fieldset>
                <fieldset>
                    <legend>рдЖрд░реНрдЯрд┐рдХрд▓ рдбрд┐рд╕реНрдкреНрд▓реЗ</legend>
                    <div class="setting-item">
                        <label for="displayModeSetting">рдХрдВрдЯреЗрдВрдЯ рдбрд┐рд╕реНрдкреНрд▓реЗ рдореЛрдб:</label>
                        <div class="setting-control">
                            <select id="displayModeSetting" style="margin-top:0;">
                                <option value="image-text">рдЗрдореЗрдЬ рдФрд░ рдЯреЗрдХреНрд╕реНрдЯ</option>
                                <option value="text-only">рдХреЗрд╡рд▓ рдЯреЗрдХреНрд╕реНрдЯ</option>
                            </select>
                        </div>
                    </div>
                </fieldset>
                <fieldset>
                    <legend>рдЯреЗрдХреНрд╕реНрдЯ рдЖрдХрд╛рд░</legend>
                    <div class="setting-item">
                        <label for="extractorFontSizeSetting">рдПрдХреНрд╕рдЯреНрд░реИрдХреНрдЯрд░ рдЖрд░реНрдЯрд┐рдХрд▓ рдлрд╝реЙрдиреНрдЯ рдЖрдХрд╛рд░:</label>
                        <div class="setting-control range-control">
                            <button onclick="adjustFontSizeSetting('extractor', -1)" class="tool-btn-secondary" style="margin:0; padding: 6px 10px; font-size:0.9em;">A-</button>
                            <span id="extractorFontSizeDisplay" style="min-width:40px; text-align:center;">16px</span>
                            <button onclick="adjustFontSizeSetting('extractor', 1)" class="tool-btn-secondary" style="margin:0; padding: 6px 10px; font-size:0.9em;">A+</button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label for="libraryFontSizeSetting">рд▓рд╛рдЗрдмреНрд░реЗрд░реА рдЖрд░реНрдЯрд┐рдХрд▓ рдлрд╝реЙрдиреНрдЯ рдЖрдХрд╛рд░:</label>
                        <div class="setting-control range-control">
                             <button onclick="adjustFontSizeSetting('library', -1)" class="tool-btn-secondary" style="margin:0; padding: 6px 10px; font-size:0.9em;">A-</button>
                            <span id="libraryFontSizeDisplay" style="min-width:40px; text-align:center;">16px</span>
                            <button onclick="adjustFontSizeSetting('library', 1)" class="tool-btn-secondary" style="margin:0; padding: 6px 10px; font-size:0.9em;">A+</button>
                        </div>
                    </div>
                </fieldset>
                <fieldset>
                    <legend>рдЯреЗрдХреНрд╕реНрдЯ-рдЯреВ-рд╕реНрдкреАрдЪ (TTS)</legend>
                    <div class="setting-item">
                        <label for="ttsMethodSetting">TTS рдЗрдВрдЬрди:</label>
                        <div class="setting-control">
                             <select id="ttsMethodSetting" style="margin-top:0;">
                                <option value="stream">Google рд╕реНрдЯреНрд░реАрдо (рдЕрдиреБрд╢рдВрд╕рд┐рдд)</option>
                                <option value="local">рдбрд┐рд╡рд╛рдЗрд╕ TTS</option>
                            </select>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label for="ttsRateSetting">рдмреЛрд▓рдиреЗ рдХреА рдЧрддрд┐:</label>
                        <div class="setting-control range-control">
                            <input type="range" id="ttsRateSetting" min="0.5" max="2" step="0.1" value="1" style="margin-top:0;">
                            <span id="ttsRateDisplaySetting">1.0x</span>
                        </div>
                    </div>
                    <div class="setting-item" id="voiceSelectorContainerSetting" style="display:none;">
                        <label for="voiceSelectorSetting">рдЖрд╡рд╛рдЬрд╝ (рдбрд┐рд╡рд╛рдЗрд╕ TTS):</label>
                        <div class="setting-control">
                            <select id="voiceSelectorSetting" style="margin-top:0;"></select>
                        </div>
                    </div>
                     <div class="setting-item" id="libVoiceSelectorContainer" style="display:none;">
                        <label for="libVoiceSelector">рдЖрд╡рд╛рдЬрд╝ (рдбрд┐рд╡рд╛рдЗрд╕ TTS):</label>
                        <div class="setting-control">
                            <select id="libVoiceSelector" onchange="setTTSVoice(this.value)" style="margin-top:0;"></select>
                        </div>
                    </div>
                </fieldset>
                <fieldset>
                    <legend>RSS рдлрд╝реАрдбреНрд╕</legend>
                    <div class="setting-item">
                        <label for="rssAutoRefreshSetting">рдСрдЯреЛ-рд░рд┐рдлреНрд░реЗрд╢ рдЕрдВрддрд░рд╛рд▓:</label>
                        <div class="setting-control">
                            <select id="rssAutoRefreshSetting" onchange="handleRssAutoRefreshChange(this.value)" style="margin-top:0;">
                                <option value="0">рдХрднреА рдирд╣реАрдВ (рдореИрдиреБрдЕрд▓)</option>
                                <option value="30">рд╣рд░ 30 рдорд┐рдирдЯ</option>
                                <option value="60">рд╣рд░ 60 рдорд┐рдирдЯ</option>
                                <option value="120">рд╣рд░ 2 рдШрдВрдЯреЗ</option>
                            </select>
                        </div>
                    </div>
                </fieldset>
                <fieldset>
                    <legend>рдСрдЯреЛрдореЗрд╢рди рдирд┐рдпрдо</legend>
                    <div id="rulesListContainer"></div>
                    <button class="tool-btn-secondary" onclick="openRuleModal()" style="margin-top:10px; margin-left:0;">рдирдпрд╛ рдирд┐рдпрдо рдмрдирд╛рдПрдБ</button>
                </fieldset>
                <fieldset class="danger-zone">
                    <legend>рдбреЗрдЯрд╛ рдкреНрд░рдмрдВрдзрди</legend>
                    <div class="setting-item">
                        <label>рд▓рд╛рдЗрдмреНрд░реЗрд░реА рдбреЗрдЯрд╛:</label>
                        <div class="setting-control">
                            <button class="tool-btn-secondary" onclick="exportLibrary()" style="background-color:var(--secondary-color); margin-top:0;">рдПрдХреНрд╕рдкреЛрд░реНрдЯ</button>
                            <button class="tool-btn-secondary" onclick="document.getElementById('importLibraryFile').click()" style="background-color:var(--secondary-color); margin-top:0;">рдЗрдВрдкреЛрд░реНрдЯ</button>
                            <button class="danger-btn" onclick="clearLibraryData()" style="margin-top:0;">рд▓рд╛рдЗрдмреНрд░реЗрд░реА рд╕рд╛рдлрд╝ рдХрд░реЗрдВ</button>
                        </div>
                    </div>
                     <div class="setting-item">
                        <label>рдмреБрдХрдорд╛рд░реНрдХ рдбреЗрдЯрд╛:</label>
                        <div class="setting-control">
                            <button class="danger-btn" onclick="clearBookmarksData()" style="margin-top:0;">рдмреБрдХрдорд╛рд░реНрдХ рд╕рд╛рдлрд╝ рдХрд░реЗрдВ</button>
                        </div>
                    </div>
                     <div class="setting-item">
                        <label>RSS рдлрд╝реАрдб рдбреЗрдЯрд╛:</label>
                        <div class="setting-control">
                            <button class="danger-btn" onclick="clearRssFeedsData()" style="margin-top:0;">RSS рдлрд╝реАрдбреНрд╕ рд╕рд╛рдлрд╝ рдХрд░реЗрдВ</button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label>рд╕рднреА рд╕реЗрдЯрд┐рдВрдЧреНрд╕ рдФрд░ рдбреЗрдЯрд╛:</label>
                        <div class="setting-control">
                            <button class="danger-btn" onclick="resetAllSettings()" style="margin-top:0;">рд╕рдм рд░реАрд╕реЗрдЯ рдХрд░реЗрдВ</button>
                        </div>
                    </div>
                </fieldset>
            </div>
            <div class="settings-modal-footer">
                <button class="tool-btn" onclick="closeSettingsModal()" style="background-color:var(--success-color); margin-top:0;">рд╕рд╣реЗрдЬреЗрдВ рдФрд░ рдмрдВрдж рдХрд░реЗрдВ</button>
            </div>
        </div>
    </div>
    
    <!-- Collections Modal -->
    <div id="collectionsModal" class="collections-modal-overlay">
        <div class="collections-modal-content">
            <div class="collections-modal-header">
                <h2>рдХрд▓реЗрдХреНрд╢рди рдкреНрд░рдмрдВрдзрд┐рдд рдХрд░реЗрдВ</h2>
                <button class="settings-close-btn" onclick="closeCollectionsModal()">├Ч</button>
            </div>
            <div class="collections-modal-body">
                <div id="collections-list"></div>
                <hr>
                <div id="add-collection-form" style="display:flex; gap:10px;">
                    <input type="text" id="newCollectionName" placeholder="рдирдпрд╛ рдХрд▓реЗрдХреНрд╢рди рдирд╛рдо" style="margin-top:0; flex-grow:1;">
                    <button class="tool-btn" onclick="addCollection()" style="margin-top:0;">рдЬреЛрдбрд╝реЗрдВ</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Rule Modal -->
    <div id="ruleModal" class="rule-modal-overlay">
        <div class="rule-modal-content">
            <div class="rule-modal-header">
                <h2 id="ruleModalTitle">рдирдпрд╛ рдирд┐рдпрдо рдмрдирд╛рдПрдБ</h2>
                <button class="settings-close-btn" onclick="closeRuleModal()">├Ч</button>
            </div>
            <div class="rule-modal-body">
                <input type="hidden" id="ruleId">
                <div class="rule-builder-item">
                    <strong>IF (рдЕрдЧрд░):</strong>
                    <select id="ruleTriggerType" onchange="updateRuleTriggerValueUI()">
                        <option value="title_contains">рд▓реЗрдЦ рдХрд╛ рд╢реАрд░реНрд╖рдХ рд╢рд╛рдорд┐рд▓ рд╣реИ</option>
                        <option value="url_contains">рд▓реЗрдЦ рдХрд╛ URL рд╢рд╛рдорд┐рд▓ рд╣реИ</option>
                        <option value="from_rss_feed">рд▓реЗрдЦ RSS рдлрд╝реАрдб рд╕реЗ рд╣реИ</option>
                    </select>
                </div>
                <div class="rule-builder-item" id="ruleTriggerValueContainer">
                    <input type="text" id="ruleTriggerValue" placeholder="рдорд╛рди рдбрд╛рд▓реЗрдВ (рдЬреИрд╕реЗ 'urgent', 'techcrunch.com')">
                </div>
                <div class="rule-builder-item">
                    <strong>THEN (рддреЛ):</strong>
                     <select id="ruleActionType" onchange="updateRuleActionValueUI()">
                        <option value="add_tag">рдЯреИрдЧ рдЬреЛрдбрд╝реЗрдВ</option>
                        <option value="assign_collection">рдХрд▓реЗрдХреНрд╢рди рдореЗрдВ рдбрд╛рд▓реЗрдВ</option>
                    </select>
                </div>
                <div class="rule-builder-item" id="ruleActionValueContainer">
                    <input type="text" id="ruleActionValue" placeholder="рдЯреИрдЧ рдХрд╛ рдирд╛рдо (рдЬреИрд╕реЗ 'work', 'important')">
                </div>
            </div>
            <div class="rule-modal-footer">
                <button class="tool-btn" onclick="saveRule()" style="background-color:var(--success-color); margin-top:0;">рдирд┐рдпрдо рд╕рд╣реЗрдЬреЗрдВ</button>
            </div>
        </div>
    </div>


    <script>
    // --- UPDATED: Embedded Service Worker Code for PWA and Offline Caching ---
    const serviceWorkerCode = `
        const CACHE_NAME = 'article-reader-pro-v2'; // Changed version to ensure update
        const AUDIO_CACHE_NAME = 'article-reader-audio-v2';
        
        // App Shell: The minimal files needed for the app to run offline
        const urlsToCache = [
            '.', // Caches the current page (e.g., arti3.html)
            'https://cdn.jsdelivr.net/npm/@mozilla/readability@0.5.0/Readability.min.js',
            'https://unpkg.com/dexie@4.0.1/dist/dexie.js',
            'https://cdn-icons-png.flaticon.com/512/864/864348.png' // Cache the icon
        ];

        self.addEventListener('install', event => {
            event.waitUntil(
                caches.open(CACHE_NAME)
                    .then(cache => {
                        console.log('Opened core cache');
                        return cache.addAll(urlsToCache);
                    })
                    .then(() => self.skipWaiting())
            );
        });

        self.addEventListener('activate', event => {
            const cacheWhitelist = [CACHE_NAME, AUDIO_CACHE_NAME];
            event.waitUntil(
                caches.keys().then(cacheNames => {
                    return Promise.all(
                        cacheNames.map(cacheName => {
                            if (cacheWhitelist.indexOf(cacheName) === -1) {
                                console.log('Deleting old cache:', cacheName);
                                return caches.delete(cacheName);
                            }
                        })
                    );
                }).then(() => self.clients.claim())
            );
        });

        self.addEventListener('fetch', event => {
            const requestUrl = new URL(event.request.url);

            // Special handling for the proxy and Google TTS audio
            if (requestUrl.href.includes('article-proxyy.rockysmail69.workers.dev')) {
                event.respondWith(
                    caches.open(AUDIO_CACHE_NAME).then(cache => {
                        return fetch(event.request).then(networkResponse => {
                            // Always fetch from network first for TTS to ensure it works, then cache
                            cache.put(event.request, networkResponse.clone());
                            return networkResponse;
                        }).catch(() => {
                            // If network fails, try to serve from cache
                            return cache.match(event.request);
                        });
                    })
                );
            } else {
                // For all other requests (app shell, scripts), use Cache-First strategy
                event.respondWith(
                    caches.match(event.request)
                        .then(response => {
                            if (response) {
                                return response; // Serve from cache
                            }
                            // If not in cache, fetch from network
                            return fetch(event.request).then(networkResponse => {
                                // Optional: You might want to cache some other requests on the fly
                                return networkResponse;
                            });
                        }
                    )
                );
            }
        });
    `;

    // --- DEXIE DATABASE SETUP ---
    const db = new Dexie('ArticleReaderProDB');
    db.version(1).stores({
        articles: '&url, title, savedAt, collectionId, *tags, isRead', // &url is the primary key
        collections: '&id, name',
        rules: '&id',
        bookmarks: '++id, addedAt, folder', // auto-incrementing primary key
        rss_feeds: '&url',
        runtime_state: '&key', // for queue, etc.
        preferences: '&key' // for simple key-value settings
    });

    // --- Helper for Preferences Store ---
    const dbprefs = {
        async get(key, defaultValue = null) {
            const item = await db.preferences.get(key);
            // Migration check: if value is stored as object from old migration, extract value property
            if (item && typeof item.value === 'object' && item.value !== null && 'value' in item.value) {
                return item.value.value;
            }
            return item ? item.value : defaultValue;
        },
        async set(key, value) {
            return db.preferences.put({ key, value });
        },
        async remove(key) {
            return db.preferences.delete(key);
        }
    };


    // --- Global Variables & Setup ---
    const MY_PRIVATE_PROXY = 'https://article-proxyy.rockysmail69.workers.dev';
    let allFoundLinks = new Set();
    let currentProcessIndex = 0;
    let isProcessing = false;
    const speechApiSupported = 'speechSynthesis' in window;
    const mediaSessionSupported = ('mediaSession' in navigator);
    let localSpeechSynth;

    // TTS Stream Preloading
    let preloadedAudioBlobs = {}; // { chunkIndex: Blob }
    let currentlyPlayingChunkIndex = -1; // Index relative to allTextChunksForStream
    let allTextChunksForStream = []; // All text chunks for the current streaming article
    const PRELOAD_AHEAD_COUNT = 2; // How many chunks to preload

    let currentAudioElement = null, currentStreamController = null;
    let localTtsQueue = [];

    let isPlaying = false;
    let isPaused = false;

    let wasSpeakingBeforeTabSwitch = false;
    let navigationHistory = [], currentHistoryIndex = -1, isNavigatingHistory = false;
    let currentDisplayMode = 'image-text';
    let isCrawlingPaused = false;
    let sleepTimerId = null, sleepTimerIntervalId = null, sleepTimerEndTime = 0, stopAtArticleEnd = false;

    let playQueue = [];
    let currentQueueIndex = -1;
    let currentArticleTotalChunks = 0;
    let visualizerContext = { audioCtx: null, analyser: null, source: null, animationFrameId: null, dataArray: null, bufferLength: 0, canvas: null, canvasCtx: null };
    let audioPlayerState = { isShuffle: false, repeatMode: 'off', unshuffledQueue: [], currentArticle: null };

    // Old localStorage keys for migration
    const OLD_STORAGE_KEYS = {
        theme: 'articleReaderTheme_s1',
        library: 'articleReaderLibrary_s9_pro',
        collections: 'articleReaderCollections_v1',
        rules: 'articleReaderRules_v1',
        fontSize: 'articleReaderFontSize_s1',
        libraryFontSize: 'articleReaderLibraryFontSize_s1',
        ttsMethod: 'articleReaderTTSMethod_v1',
        ttsRate: 'articleReaderTTSRate_v1',
        ttsVoice: 'articleReaderTTSVoice_v1',
        displayMode: 'articleReaderDisplayMode_s1',
        bookmarks: 'articleReaderBookmarks_s3',
        autoplay: 'articleReaderAutoplay_v1',
        playQueue: 'articleReaderPlayQueue_v1',
        rssFeeds: 'articleReaderRssFeeds_v2',
        focusMode: 'articleReaderFocusMode_v1',
        rssReadItems: 'articleReaderRssReadItems_v1',
        rssAutoRefresh: 'articleReaderRssAutoRefresh_v1',
        scrollPositions: 'articleReaderScrollPositions_v1',
        playbackPositions: 'articleReaderPlaybackPositions_v1'
    };


    let scrollSaveTimeout = null;
    let autoScrollInterval = null;
    let autoScrollSpeed = 50;
    const MIN_SCROLL_SPEED = 10;
    const MAX_SCROLL_SPEED = 200;
    let isAutoScrolling = false;
    let notesSaveTimeout = null;
    let rssAutoRefreshIntervalId = null;


    // --- Helper Functions ---
    async function getScrollPositions() { return (await dbprefs.get('scrollPositions', {})) }
    async function saveScrollPosition(articleUrl, scrollPercent) { if (!articleUrl) return; const positions = await getScrollPositions(); positions[btoa(encodeURIComponent(articleUrl))] = scrollPercent; await dbprefs.set('scrollPositions', positions); }
    async function getSavedScrollPosition(articleUrl) { if (!articleUrl) return null; const positions = await getScrollPositions(); return positions[btoa(encodeURIComponent(articleUrl))] || null; }
    async function savePlaybackPosition(articleUrl, type, position) { if (!articleUrl) return; const positions = await dbprefs.get('playbackPositions', {}); positions[btoa(encodeURIComponent(articleUrl))] = { type, position, timestamp: new Date().getTime() }; await dbprefs.set('playbackPositions', positions); }
    async function getPlaybackPosition(articleUrl) { if (!articleUrl) return null; let positions = await dbprefs.get('playbackPositions', {}); const articleId = btoa(encodeURIComponent(articleUrl)); if (positions[articleId] && (new Date().getTime() - positions[articleId].timestamp > 30 * 24 * 60 * 60 * 1000)) { delete positions[articleId]; await dbprefs.set('playbackPositions', positions); return null; } return positions[articleId] || null; }
    async function clearPlaybackPosition(articleUrl) { if (!articleUrl) return; let positions = await dbprefs.get('playbackPositions', {}); const articleId = btoa(encodeURIComponent(articleUrl)); if (positions[articleId]) { delete positions[articleId]; await dbprefs.set('playbackPositions', positions); } }
    async function saveQueue() { const queueToSave = { items: playQueue, currentIndex: currentQueueIndex, isShuffle: audioPlayerState.isShuffle, repeatMode: audioPlayerState.repeatMode, unshuffledQueue: audioPlayerState.unshuffledQueue }; await db.runtime_state.put({ key: 'playQueue', value: queueToSave }); }
    async function loadQueue() { const savedState = await db.runtime_state.get('playQueue'); if (savedState && savedState.value && Array.isArray(savedState.value.items)) { const savedQueue = savedState.value; playQueue = savedQueue.items; currentQueueIndex = savedQueue.currentIndex; audioPlayerState.isShuffle = savedQueue.isShuffle || false; audioPlayerState.repeatMode = savedQueue.repeatMode || 'off'; audioPlayerState.unshuffledQueue = savedQueue.unshuffledQueue || []; updateQueueDisplay(); } }

    function setupVisualizer(audioElement) { if (!visualizerContext.audioCtx) { visualizerContext.audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } if (visualizerContext.source) { visualizerContext.source.disconnect(); } visualizerContext.canvas = document.getElementById('audioVisualizer'); visualizerContext.canvasCtx = visualizerContext.canvas.getContext('2d'); try { visualizerContext.source = visualizerContext.audioCtx.createMediaElementSource(audioElement); visualizerContext.analyser = visualizerContext.audioCtx.createAnalyser(); visualizerContext.analyser.fftSize = 256; visualizerContext.bufferLength = visualizerContext.analyser.frequencyBinCount; visualizerContext.dataArray = new Uint8Array(visualizerContext.bufferLength); visualizerContext.source.connect(visualizerContext.analyser); visualizerContext.analyser.connect(visualizerContext.audioCtx.destination); drawVisualization(); } catch (e) { console.error("Error setting up visualizer:", e); if (e.name === "InvalidStateError" && audioElement.readyState === 0) { console.warn("Visualizer setup failed due to audio element not ready. Retrying on canplay."); audioElement.addEventListener('canplay', () => setupVisualizer(audioElement), {once: true}); } } }
    function drawVisualization() { if (!visualizerContext.analyser) return; visualizerContext.animationFrameId = requestAnimationFrame(drawVisualization); visualizerContext.analyser.getByteFrequencyData(visualizerContext.dataArray); const { canvas, canvasCtx, bufferLength, dataArray } = visualizerContext; canvasCtx.clearRect(0, 0, canvas.width, canvas.height); const barWidth = (canvas.width / bufferLength) * 2.5; let barHeight; let x = 0; const themeColor = getComputedStyle(document.documentElement).getPropertyValue('--player-red').trim(); for (let i = 0; i < bufferLength; i++) { barHeight = dataArray[i] / 2; canvasCtx.fillStyle = themeColor; canvasCtx.fillRect(x, (canvas.height - barHeight) / 2, barWidth, barHeight); x += barWidth + 1; } }
    function stopVisualization() { if (visualizerContext.animationFrameId) { cancelAnimationFrame(visualizerContext.animationFrameId); visualizerContext.animationFrameId = null; } const canvas = document.getElementById('audioVisualizer'); if (canvas) { const ctx = canvas.getContext('2d'); ctx.clearRect(0, 0, canvas.width, canvas.height); } if (visualizerContext.source) { visualizerContext.source.disconnect(); visualizerContext.source = null; } if (visualizerContext.analyser) { visualizerContext.analyser.disconnect(); visualizerContext.analyser = null;} }
    function openQueueModal() { updateQueueDisplay(); document.getElementById('queueModal').classList.add('show'); }
    function closeQueueModal() { document.getElementById('queueModal').classList.remove('show'); }
    async function addToQueue(articleData, playNext = false) { if (!articleData || !articleData.url) { showToast("рдХреНрдпреВ рдореЗрдВ рдЬреЛрдбрд╝рдиреЗ рдХреЗ рд▓рд┐рдП рдЕрдорд╛рдиреНрдп рд▓реЗрдЦ рдбреЗрдЯрд╛ред", "error"); return; } if (playQueue.find(item => item.url === articleData.url)) { showToast("рдпрд╣ рдЖрд░реНрдЯрд┐рдХрд▓ рдкрд╣рд▓реЗ рд╕реЗ рд╣реА рдХреНрдпреВ рдореЗрдВ рд╣реИред", "warning"); return; } if (!articleData.title) articleData.title = "рдЕрдЬреНрдЮрд╛рдд рд╢реАрд░реНрд╖рдХ"; if (playNext) { playQueue.splice(currentQueueIndex + 1, 0, articleData); showToast(`'${articleData.title.substring(0, 20)}...' рдЕрдЧрд▓рд╛ рдмрдЬреЗрдЧрд╛ред`, 'success'); } else { playQueue.push(articleData); showToast(`'${articleData.title.substring(0, 20)}...' рдХреНрдпреВ рдореЗрдВ рдЬреЛрдбрд╝рд╛ рдЧрдпрд╛ред`, 'success'); } if (!isPlaying && !isPaused && playQueue.length > 0 && playQueue.length === (playNext ? currentQueueIndex + 2 : playQueue.length)) { startQueuePlayback(); } updateQueueDisplay(); await saveQueue(); }
    async function removeFromQueue(index) { if (index > -1 && index < playQueue.length) { const wasCurrentlyPlayingItem = (index === currentQueueIndex); playQueue.splice(index, 1); if (index < currentQueueIndex) { currentQueueIndex--; } else if (index === currentQueueIndex && playQueue.length === 0) { currentQueueIndex = -1; } else if (index === currentQueueIndex && index >= playQueue.length) { currentQueueIndex = playQueue.length > 0 ? playQueue.length -1 : -1; } updateQueueDisplay(); await saveQueue(); if (wasCurrentlyPlayingItem) { await stopTTS(); if(playQueue.length > 0 && currentQueueIndex !== -1 && currentQueueIndex < playQueue.length) { playNextInQueueOrAutoplay(true); } else if (playQueue.length > 0) { playQueueItem(0); } else { hideAudioPlayer(); audioPlayerState.currentArticle = null; } } } }
    async function clearQueue() { playQueue = []; currentQueueIndex = -1; await stopTTS(); updateQueueDisplay(); await saveQueue(); showToast("рдХреНрдпреВ рд╕рд╛рдлрд╝ рдХрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред", "info"); hideAudioPlayer(); audioPlayerState.currentArticle = null;}

    function updateQueueDisplay() {
        const queueList = document.getElementById('queue-list');
        const queueCount = document.getElementById('queue-count');
        const viewQueueBtn = document.getElementById('viewQueueBtn');
        queueList.innerHTML = '';

        if (playQueue.length === 0) {
            queueList.innerHTML = '<li><p style="text-align:center; padding: 20px 0; font-style:italic;">рдХреНрдпреВ рдЦрд╛рд▓реА рд╣реИред</p></li>';
            if (viewQueueBtn) viewQueueBtn.style.display = 'none';
        } else {
            if (viewQueueBtn) {
                 viewQueueBtn.style.display = 'inline-block';
                 queueCount.textContent = playQueue.length;
            }
            playQueue.forEach((item, index) => {
                const li = document.createElement('li');
                li.className = 'queue-item';
                if (index === currentQueueIndex && (isPlaying || isPaused)) li.classList.add('playing');
                li.dataset.index = index;
                li.draggable = true;
                li.innerHTML = `
                    <span style="cursor: move;" title="рдХреНрд░рдо рдмрджрд▓реЗрдВ">та┐</span>
                    <span class="queue-item-title" title="рдкреНрд▓реЗ рдХрд░реЗрдВ: ${item.title}" onclick="handleQueueItemClick(${index})">${item.title}</span>
                    <button class="delete-btn" title="рдХреНрдпреВ рд╕реЗ рд╣рдЯрд╛рдПрдВ" onclick="removeFromQueue(${index})">тЬЧ</button>
                `;
                queueList.appendChild(li);
            });
            addQueueDragDropListeners();
        }
    }

    function addQueueDragDropListeners() { const items = document.querySelectorAll('#queue-list .queue-item'); let dragStartIndex; items.forEach(item => { item.addEventListener('dragstart', e => { dragStartIndex = parseInt(e.currentTarget.dataset.index); e.currentTarget.classList.add('dragging'); }); item.addEventListener('dragend', e => e.currentTarget.classList.remove('dragging')); item.addEventListener('dragover', e => e.preventDefault()); item.addEventListener('drop', async e => { e.preventDefault(); const dragEndIndex = parseInt(e.currentTarget.dataset.index); const [reorderedItem] = playQueue.splice(dragStartIndex, 1); playQueue.splice(dragEndIndex, 0, reorderedItem); if (dragStartIndex === currentQueueIndex) currentQueueIndex = dragEndIndex; else if (dragStartIndex < currentQueueIndex && dragEndIndex >= currentQueueIndex) currentQueueIndex--; else if (dragStartIndex > currentQueueIndex && dragEndIndex <= currentQueueIndex) currentQueueIndex++; updateQueueDisplay(); await saveQueue(); }); }); }

    function startQueuePlayback() {
        if (playQueue.length > 0) {
            const indexToPlay = currentQueueIndex !== -1 && currentQueueIndex < playQueue.length ? currentQueueIndex : 0;
            if (indexToPlay < playQueue.length) {
                playQueueItem(indexToPlay);
            } else if (playQueue.length > 0) {
                playQueueItem(0);
            }
        }
    }

    async function handleQueueItemClick(index) {
        if (index >= 0 && index < playQueue.length) {
            if (index === currentQueueIndex && (isPlaying || isPaused)) {
                handlePlayPause();
                return;
            }
            await playQueueItem(index);
            closeQueueModal();
        } else {
            console.error("Invalid index for queue item click:", index);
        }
    }

    async function playQueueItem(index) {
        if (index >= 0 && index < playQueue.length) {
            currentQueueIndex = index;
            await saveQueue();
            const articleData = playQueue[index];
            await createAudioPlayer(articleData);
            updateQueueDisplay();
        } else {
            if (audioPlayerState.repeatMode === 'all' && playQueue.length > 0) {
                await playQueueItem(0);
            } else {
                currentQueueIndex = -1;
                await saveQueue();
                if (isPlaying || isPaused) {
                     showToast("рдкреНрд▓реЗрдмреИрдХ рдХреНрдпреВ рд╕рдорд╛рдкреНрддред", "info");
                }
                await stopTTS();
                updateQueueDisplay();
                hideAudioPlayer();
                audioPlayerState.currentArticle = null;
            }
        }
    }

    async function createAudioPlayer(articleData) {
        await showSavedArticle(articleData);
        const playerContainer = document.getElementById('audioPlayerContainer');
        playerContainer.style.display = 'flex';
        playerContainer.querySelector('.play-pause-btn').onclick = handlePlayPause;
        playerContainer.querySelector('.next-btn').onclick = () => playNextInQueueOrAutoplay();
        playerContainer.querySelector('.prev-btn').onclick = playPreviousInQueue;
        playerContainer.querySelector('.shuffle-btn').onclick = toggleShuffle;
        playerContainer.querySelector('.repeat-btn').onclick = toggleRepeat;
        playerContainer.querySelector('.progress-bar').oninput = (e) => seekAudio(e.target.value);

        if (!audioPlayerState.currentArticle || articleData.url !== audioPlayerState.currentArticle.url || (!isPlaying && !isPaused)) {
            await playTTS(articleData);
        } else {
            audioPlayerState.currentArticle = articleData;
            updatePlayerUI();
        }
    }

    function hideAudioPlayer() { const playerContainer = document.getElementById('audioPlayerContainer'); if (playerContainer) { playerContainer.style.display = 'none'; } stopVisualization(); }

    async function handlePlayPause() {
        if (!audioPlayerState.currentArticle) {
            if (playQueue.length > 0) {
                const indexToPlay = currentQueueIndex >= 0 && currentQueueIndex < playQueue.length ? currentQueueIndex : 0;
                if (indexToPlay < playQueue.length) playQueueItem(indexToPlay);
                else showToast("рдЪрд▓рд╛рдиреЗ рдХреЗ рд▓рд┐рдП рдХреЛрдИ рдЖрд░реНрдЯрд┐рдХрд▓ рдирд╣реАрдВ рд╣реИред", "warning");
            } else {
                showToast("рдЪрд▓рд╛рдиреЗ рдХреЗ рд▓рд┐рдП рдХреЛрдИ рдЖрд░реНрдЯрд┐рдХрд▓ рдирд╣реАрдВ рд╣реИред", "warning");
            }
            return;
        }

        if (isPlaying) {
            await pauseTTS();
        } else if (isPaused) {
            await resumeTTS();
        } else {
            await playTTS(audioPlayerState.currentArticle);
        }
    }

    function updatePlayerUI() {
        const playerContainer = document.getElementById('audioPlayerContainer');
        if (!playerContainer) return;

        const playPauseBtn = playerContainer.querySelector('.play-pause-btn');
        let showPauseIcon = isPlaying && audioPlayerState.currentArticle;
        playPauseBtn.innerHTML = showPauseIcon ? 'тП╕я╕П' : 'тЦ╢я╕П';

        const shuffleBtn = playerContainer.querySelector('.shuffle-btn');
        shuffleBtn.classList.toggle('active', audioPlayerState.isShuffle);
        const repeatBtn = playerContainer.querySelector('.repeat-btn');
        repeatBtn.classList.toggle('active', audioPlayerState.repeatMode !== 'off');
        if (audioPlayerState.repeatMode === 'one') {
            repeatBtn.innerHTML = 'ЁЯФБ<sub style="font-size: 0.5em; vertical-align: top;">1</sub>';
        } else {
            repeatBtn.innerHTML = 'ЁЯФБ';
        }
        const prevBtn = playerContainer.querySelector('.prev-btn');
        const nextBtn = playerContainer.querySelector('.next-btn');

        if (playQueue.length > 0 && currentQueueIndex !== -1) {
            prevBtn.disabled = currentQueueIndex <= 0;
            nextBtn.disabled = currentQueueIndex >= playQueue.length - 1 && audioPlayerState.repeatMode !== 'all';
        } else {
            prevBtn.disabled = true;
            nextBtn.disabled = true;
        }
        updateQueueDisplay();
    }

    async function playPreviousInQueue() { if (currentQueueIndex > 0) { await playQueueItem(currentQueueIndex - 1); } }
    async function toggleShuffle() { audioPlayerState.isShuffle = !audioPlayerState.isShuffle; if (audioPlayerState.isShuffle) { audioPlayerState.unshuffledQueue = [...playQueue]; if (currentQueueIndex !== -1 && currentQueueIndex < playQueue.length) { const currentItem = playQueue[currentQueueIndex]; const tail = playQueue.filter((_,idx) => idx !== currentQueueIndex); for (let i = tail.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [tail[i], tail[j]] = [tail[j], tail[i]]; } playQueue = [currentItem, ...tail]; currentQueueIndex = 0; } showToast("рд╢рдлрд▓ рдЪрд╛рд▓реВред", "success"); } else { if (audioPlayerState.unshuffledQueue.length > 0) { const currentUrl = playQueue[currentQueueIndex]?.url; playQueue = [...audioPlayerState.unshuffledQueue]; currentQueueIndex = playQueue.findIndex(item => item.url === currentUrl); if (currentQueueIndex === -1 && playQueue.length > 0) currentQueueIndex = 0; } showToast("рд╢рдлрд▓ рдмрдВрджред", "info"); } updateQueueDisplay(); await saveQueue(); updatePlayerUI(); }
    async function toggleRepeat() { const modes = ['off', 'all', 'one']; const currentIndexVal = modes.indexOf(audioPlayerState.repeatMode); audioPlayerState.repeatMode = modes[(currentIndexVal + 1) % modes.length]; if (audioPlayerState.repeatMode === 'off') showToast("рд░рд┐рдкреАрдЯ рдмрдВрджред"); if (audioPlayerState.repeatMode === 'all') showToast("рдкреВрд░реА рдкреНрд▓реЗрд▓рд┐рд╕реНрдЯ рд░рд┐рдкреАрдЯ рдХрд░реЗрдВред"); if (audioPlayerState.repeatMode === 'one') showToast("рдпрд╣ рдЯреНрд░реИрдХ рд░рд┐рдкреАрдЯ рдХрд░реЗрдВред"); updatePlayerUI(); await saveQueue(); }
    function updateAudioProgress(e) { const { duration, currentTime } = e.target; const playerContainer = document.getElementById('audioPlayerContainer'); if (duration && playerContainer && isFinite(duration) && isFinite(currentTime)) { const progressPercent = (currentTime / duration) * 100; const progressBar = playerContainer.querySelector('.progress-bar'); progressBar.value = progressPercent; progressBar.style.backgroundSize = `${progressPercent}% 100%`; playerContainer.querySelector('.current-time').textContent = formatTime(currentTime); playerContainer.querySelector('.total-time').textContent = formatTime(duration); } else if (playerContainer) { playerContainer.querySelector('.current-time').textContent = formatTime(0); playerContainer.querySelector('.total-time').textContent = formatTime(0); }}
    function seekAudio(value) { if (currentAudioElement && currentAudioElement.duration && isFinite(currentAudioElement.duration)) { currentAudioElement.currentTime = (value / 100) * currentAudioElement.duration; } }
    function formatTime(seconds) { if (!isFinite(seconds) || seconds < 0) return "0:00"; const floorSeconds = Math.floor(seconds); const m = Math.floor(floorSeconds / 60); const s = floorSeconds % 60; return `${m}:${s.toString().padStart(2, '0')}`; }

    async function playTTS(article) {
        if (!article) {
            console.warn("playTTS called with null/undefined article");
            await stopTTS();
            hideAudioPlayer();
            return;
        }
        await stopTTS(); // This will also clear preloads for the previous article

        audioPlayerState.currentArticle = article;
        isPlaying = true;
        isPaused = false;
        updateMediaSession(article, 'playing');
        updatePlayerUI();

        const method = await dbprefs.get('ttsMethod', 'stream');
        const savedPosition = await getPlaybackPosition(article.url);

        if (method === 'local') {
            await playLocalTTSInternal(article, savedPosition);
        } else {
            await playStreamTTSInternal(article, savedPosition);
        }
    }

    async function pauseTTS() {
        if (!isPlaying) return;
        const method = await dbprefs.get('ttsMethod', 'stream');

        if (method === 'stream' && currentAudioElement) {
            currentAudioElement.pause();
        } else if (method === 'local' && speechApiSupported && localSpeechSynth && localSpeechSynth.speaking) {
            localSpeechSynth.pause();
        }
        isPlaying = false;
        isPaused = true;
        updatePlayerUI();
        updateMediaSession(audioPlayerState.currentArticle, 'paused');
    }

    async function resumeTTS() {
        if (!isPaused || !audioPlayerState.currentArticle) return;
        const method = await dbprefs.get('ttsMethod', 'stream');
        isPaused = false;
        isPlaying = true;

        if (method === 'stream' && currentAudioElement) {
            currentAudioElement.play().catch(async e => { console.error("Error resuming stream audio:", e); await stopTTS();});
        } else if (method === 'local' && speechApiSupported && localSpeechSynth && localSpeechSynth.paused) {
            localSpeechSynth.resume();
        }
        updatePlayerUI();
        updateMediaSession(audioPlayerState.currentArticle, 'playing');
    }

    async function stopTTS() {
        const currentArticleForPos = audioPlayerState.currentArticle;
        if (currentArticleForPos?.url && playQueue.length === 0 && (isPlaying || isPaused)) {
            const method = await dbprefs.get('ttsMethod', 'stream');
            let positionToSave = -1;

            if (method === 'stream') {
                positionToSave = currentlyPlayingChunkIndex;
            } else if (method === 'local') {
                positionToSave = currentArticleTotalChunks - localTtsQueue.length -1;
            }

            if (positionToSave >= 0 && positionToSave < currentArticleTotalChunks -1 ) {
                await savePlaybackPosition(currentArticleForPos.url, method, positionToSave);
            } else {
                 await clearPlaybackPosition(currentArticleForPos.url);
            }
        }

        stopVisualization();
        if (currentStreamController) {
            currentStreamController.abort();
            currentStreamController = null;
        }
        if (currentAudioElement) {
            currentAudioElement.pause();
            currentAudioElement.removeAttribute('src');
            currentAudioElement.load();
            currentAudioElement = null;
        }
        if (speechApiSupported && localSpeechSynth) {
            localSpeechSynth.cancel();
        }

        isPlaying = false;
        isPaused = false;
        localTtsQueue = [];

        preloadedAudioBlobs = {};
        allTextChunksForStream = [];
        currentlyPlayingChunkIndex = -1;


        if (mediaSessionSupported) {
            navigator.mediaSession.playbackState = 'none';
            navigator.mediaSession.metadata = null;
        }
        updatePlayerUI();
    }

    async function playLocalTTSInternal(article, savedPosition = null) {
        if (!speechApiSupported || !article.textContent) {
            showToast("рдмреЛрд▓рдиреЗ рдХреЗ рд▓рд┐рдП рдЯреЗрдХреНрд╕реНрдЯ рдирд╣реАрдВ рд╣реИ рдпрд╛ рдбрд┐рд╡рд╛рдЗрд╕ TTS рд╕рдорд░реНрдерд┐рдд рдирд╣реАрдВ рд╣реИред", "error");
            await stopTTS();
            return;
        }
        const fullText = (article.title || "") + ". " + article.textContent;
        const allChunks = fullText.match(/[^.!?]+[.!?]*\s*/g) || [fullText];
        currentArticleTotalChunks = allChunks.length;
        let startIndex = 0;
        if (playQueue.length === 0 && savedPosition && savedPosition.type === 'local' && savedPosition.position < allChunks.length) {
            startIndex = savedPosition.position;
        }
        localTtsQueue = allChunks.slice(startIndex);
        if (localTtsQueue.length === 0) {
            showToast("рдмреЛрд▓рдиреЗ рдХреЗ рд▓рд┐рдП рдХреЛрдИ рдЯреЗрдХреНрд╕реНрдЯ рдирд╣реАрдВ рдорд┐рд▓рд╛ред", 'error');
            await stopTTS();
            return;
        }
        await processLocalTtsQueueInternal();
    }

    async function processLocalTtsQueueInternal() {
        if (!isPlaying || localTtsQueue.length === 0) {
            if (isPlaying && audioPlayerState.currentArticle) {
                const currentArticleUrl = audioPlayerState.currentArticle.url;
                await clearPlaybackPosition(currentArticleUrl);
                if (audioPlayerState.repeatMode === 'one') {
                    await playTTS(audioPlayerState.currentArticle);
                    return;
                }
                if (stopAtArticleEnd) {
                    showToast("рдЖрд░реНрдЯрд┐рдХрд▓ рд╕рдорд╛рдкреНрддред рд╕реНрд▓реАрдк рдЯрд╛рдЗрдорд░ рдХреЗ рдЕрдиреБрд╕рд╛рд░ рдСрдбрд┐рдпреЛ рд░реЛрдХрд╛ рдЬрд╛ рд░рд╣рд╛ рд╣реИред", "info");
                    cancelSleepTimer();
                    await stopTTS();
                } else {
                    const willPlayNext = await playNextInQueueOrAutoplay();
                    if (!willPlayNext && playQueue.length === 0) {
                         await stopTTS();
                         hideAudioPlayer();
                         audioPlayerState.currentArticle = null;
                    } else if (!willPlayNext) {
                        await stopTTS();
                    }
                }
            }
            return;
        }

        if (localSpeechSynth.speaking || localSpeechSynth.pending) {
            setTimeout(processLocalTtsQueueInternal, 100);
            return;
        }
        const chunk = localTtsQueue.shift();
        if (!chunk || !chunk.trim()) {
            processLocalTtsQueueInternal();
            return;
        }
        const utterance = new SpeechSynthesisUtterance(chunk);
        const rate = parseFloat(await dbprefs.get('ttsRate', '1'));
        const voiceURI = await dbprefs.get('ttsVoice');
        const voices = localSpeechSynth.getVoices();
        if (voices.length === 0 && speechApiSupported) {
            showToast("рдЖрд╡рд╛рдЬрд╝реЗрдВ рдЕрднреА рднреА рд▓реЛрдб рд╣реЛ рд░рд╣реА рд╣реИрдВ, рдХреГрдкрдпрд╛ рдХреБрдЫ рдХреНрд╖рдг рдкреНрд░рддреАрдХреНрд╖рд╛ рдХрд░реЗрдВред", "warning");
            localTtsQueue.unshift(chunk);
            setTimeout(processLocalTtsQueueInternal, 1000);
            return;
        }
        const selectedVoice = voices.find(v => v.voiceURI === voiceURI);
        utterance.lang = selectedVoice ? selectedVoice.lang : 'hi-IN';
        utterance.rate = rate;
        if (selectedVoice) utterance.voice = selectedVoice;
        utterance.onend = () => { if(isPlaying) setTimeout(processLocalTtsQueueInternal, 50); };
        utterance.onerror = async (e) => { if (e.error === 'interrupted') return; console.error("SpeechSynthesisUtterance Error:", e); showToast(`рдбрд┐рд╡рд╛рдЗрд╕ TTS рдореЗрдВ рддреНрд░реБрдЯрд┐: ${e.error || 'рдЕрдЬреНрдЮрд╛рдд'}`, 'error', 6000); await stopTTS(); };
        setTimeout(() => { if(isPlaying) localSpeechSynth.speak(utterance); }, 10);
    }

    async function playStreamTTSInternal(article, savedPosition = null) {
        const fullText = (article.title || "") + ". " + article.textContent;
        allTextChunksForStream = fullText.replace(/\s+/g, ' ').trim().match(/.{1,180}/g) || [];
        currentArticleTotalChunks = allTextChunksForStream.length;

        if (allTextChunksForStream.length === 0) {
            showToast("рдмреЛрд▓рдиреЗ рдХреЗ рд▓рд┐рдП рдЯреЗрдХреНрд╕реНрдЯ рдирд╣реАрдВ рд╣реИред", "error");
            await stopTTS();
            return;
        }

        currentlyPlayingChunkIndex = 0;
        if (playQueue.length === 0 && savedPosition && savedPosition.type === 'stream' && savedPosition.position < currentArticleTotalChunks) {
            currentlyPlayingChunkIndex = savedPosition.position;
        }

        currentStreamController = new AbortController();
        preloadedAudioBlobs = {}; // Clear preloads for new article

        processAudioStreamQueue();
    }
    async function preloadNextAudioChunk(chunkIndexToLoad) {
        if (chunkIndexToLoad >= allTextChunksForStream.length || preloadedAudioBlobs[chunkIndexToLoad] || !isPlaying || isPaused) {
            return;
        }
        const chunkText = allTextChunksForStream[chunkIndexToLoad];
        if (!chunkText) return;
        try {
            const ttsUrl = `https://translate.google.com/translate_tts?ie=UTF-8&q=${encodeURIComponent(chunkText)}&tl=hi&client=tw-ob`;
            const proxyUrl = `${MY_PRIVATE_PROXY}/?url=${encodeURIComponent(ttsUrl)}`;
            const response = await fetch(proxyUrl, { signal: currentStreamController?.signal });
            if (!response.ok) { console.error(`Preload API Error ${response.status} for chunk ${chunkIndexToLoad}`); return; }
            const blob = await response.blob();
            if (blob.size === 0) { console.error(`Empty audio data for preloaded chunk ${chunkIndexToLoad}`); return; }
            preloadedAudioBlobs[chunkIndexToLoad] = blob;
        } catch (error) { if (error.name !== 'AbortError') { console.error(`Error preloading chunk ${chunkIndexToLoad}:`, error.message); } }
    }

    async function processAudioStreamQueue() {
        if (!isPlaying) return;
        if (currentlyPlayingChunkIndex >= allTextChunksForStream.length) {
            if (isPlaying && audioPlayerState.currentArticle) {
                const currentArticleUrl = audioPlayerState.currentArticle.url;
                await clearPlaybackPosition(currentArticleUrl);
                if (audioPlayerState.repeatMode === 'one') { await playTTS(audioPlayerState.currentArticle); return; }
                if (stopAtArticleEnd) { showToast("рдЖрд░реНрдЯрд┐рдХрд▓ рд╕рдорд╛рдкреНрддред рд╕реНрд▓реАрдк рдЯрд╛рдЗрдорд░ рдХреЗ рдЕрдиреБрд╕рд╛рд░ рдСрдбрд┐рдпреЛ рд░реЛрдХрд╛ рдЬрд╛ рд░рд╣рд╛ рд╣реИред", "info"); cancelSleepTimer(); await stopTTS(); }
                else { const willPlayNext = await playNextInQueueOrAutoplay(); if (!willPlayNext && playQueue.length === 0) { await stopTTS(); hideAudioPlayer(); audioPlayerState.currentArticle = null; } else if (!willPlayNext) { await stopTTS(); } }
            }
            return;
        }
        if (isPaused) return;

        let audioBlobToPlay = preloadedAudioBlobs[currentlyPlayingChunkIndex];
        let audioUrl;

        if (audioBlobToPlay) {
            audioUrl = URL.createObjectURL(audioBlobToPlay);
            delete preloadedAudioBlobs[currentlyPlayingChunkIndex];
        } else {
            const chunkText = allTextChunksForStream[currentlyPlayingChunkIndex];
            if (!chunkText) { currentlyPlayingChunkIndex++; processAudioStreamQueue(); return; }
            try {
                const ttsUrl = `https://translate.google.com/translate_tts?ie=UTF-8&q=${encodeURIComponent(chunkText)}&tl=hi&client=tw-ob`;
                const proxyUrl = `${MY_PRIVATE_PROXY}/?url=${encodeURIComponent(ttsUrl)}`;
                const response = await fetch(proxyUrl, { signal: currentStreamController?.signal });
                if (!response.ok) throw new Error(`API Error ${response.status} for chunk ${currentlyPlayingChunkIndex}`);
                const blob = await response.blob();
                if (blob.size === 0) throw new Error(`Empty audio data for chunk ${currentlyPlayingChunkIndex}`);
                audioUrl = URL.createObjectURL(blob);
            } catch (error) { if (error.name !== 'AbortError') { showToast(`рд╕реНрдЯреНрд░реАрдорд┐рдВрдЧ рддреНрд░реБрдЯрд┐ (chunk ${currentlyPlayingChunkIndex}): ${error.message}`, 'error'); await stopTTS(); } return; }
        }

        currentAudioElement = new Audio(audioUrl);
        if (visualizerContext.audioCtx && visualizerContext.audioCtx.state === 'suspended') { visualizerContext.audioCtx.resume(); }
        setupVisualizer(currentAudioElement);
        currentAudioElement.addEventListener('timeupdate', updateAudioProgress);
        currentAudioElement.addEventListener('loadedmetadata', updateAudioProgress);
        currentAudioElement.playbackRate = parseFloat(await dbprefs.get('ttsRate', '1'));
        currentAudioElement.play().catch(async err => { showToast(`рдСрдбрд┐рдпреЛ рдЪрд▓рд╛рдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐ (chunk ${currentlyPlayingChunkIndex}): ${err.message}`, "error"); console.error("Audio play error:", err); await stopTTS(); });
        currentAudioElement.onended = () => { URL.revokeObjectURL(audioUrl); if (isPlaying) { currentlyPlayingChunkIndex++; processAudioStreamQueue(); } };
        currentAudioElement.onerror = async (e) => { URL.revokeObjectURL(audioUrl); showToast(`рдСрдбрд┐рдпреЛ рдкреНрд▓реЗрдмреИрдХ рддреНрд░реБрдЯрд┐ (chunk ${currentlyPlayingChunkIndex})`, "error"); console.error("Audio element error event:", e); await stopTTS(); };

        for (let i = 1; i <= PRELOAD_AHEAD_COUNT; i++) {
            const indexToPreload = currentlyPlayingChunkIndex + i;
            if (indexToPreload < allTextChunksForStream.length && !preloadedAudioBlobs[indexToPreload]) {
                preloadNextAudioChunk(indexToPreload).catch(err => console.error("Preload promise rejected:", err));
            }
        }
    }


    // --- Core Functions (UI, Data Management etc.) ---
    function removeUrlsFromText(text) {
        if (!text) return "";
        const urlRegex = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])|(\bwww\.[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
        return text.replace(urlRegex, '').replace(/\s+/g, ' ').trim();
    }

    async function toggleTheme(themeName) {
        document.body.classList.remove('dark-mode', 'sepia-mode', 'light-mode', 'high-contrast-mode');
        if (themeName === 'dark') document.body.classList.add('dark-mode');
        else if (themeName === 'sepia') document.body.classList.add('sepia-mode');
        else if (themeName === 'high-contrast') document.body.classList.add('high-contrast-mode');
        else document.body.classList.add('light-mode');
        await dbprefs.set('theme', themeName);
    }
    async function applySavedTheme() { const savedTheme = await dbprefs.get('theme', 'light'); await toggleTheme(savedTheme); }

    let previousToolName = '';
    async function openTool(evt, toolName) {
        const currentActiveTab = document.querySelector('.tab-link.active');
        if (evt && currentActiveTab === evt.currentTarget && document.getElementById(toolName).style.display === 'block') return;

        if (previousToolName === 'MyLibrary') {
            const contentWrapper = document.getElementById('lib-article-text-content');
            if (contentWrapper) contentWrapper.onscroll = null;
            clearTimeout(scrollSaveTimeout);
            if (isAutoScrolling) { toggleAutoScroll(); } // Stop autoscroll when leaving library view
            const libProgressBarContainer = document.getElementById('library-reading-progress-container');
            if (libProgressBarContainer) libProgressBarContainer.style.display = 'none';
        }
        document.querySelectorAll('.extractor-reading-progress-container').forEach(el => el.style.display = 'none');


        document.querySelectorAll('.tool-content').forEach(el => el.style.display = 'none');
        document.querySelectorAll('.tab-link').forEach(el => el.classList.remove('active'));
        const toolElement = document.getElementById(toolName);
        if (toolElement) toolElement.style.display = 'block';
        const targetTab = evt ? evt.currentTarget : document.querySelector(`.tab-link[onclick*="'${toolName}'"]`);
        if (targetTab) targetTab.classList.add('active');

        if (toolName === 'MyLibrary') { await loadLibrary(); await populateTagFilter(); await populateCollectionFilters(); }
        else if (toolName === 'Bookmarks') { await loadBookmarks(); }
        else if (toolName === 'RSSFeeds') { const feeds = await getSubscribedFeeds(); await displaySubscribedFeeds(feeds); if(feeds.length > 0 && !document.getElementById('rssArticlesList').hasChildNodes()){ await displayRssFeedArticles(feeds[0]); } await updateRssFeedCount(); }
        else if (toolName === 'Statistics') { await renderStatistics(); }
        
        if (toolName !== 'ArticleExtractor') {
            document.getElementById('internalNavHistoryContainer').style.display = 'none';
            document.getElementById('toggleCrawlBtn').style.display = 'none';
        } else {
            updateHistoryButtons();
        }
        previousToolName = toolName;
    }
    async function fetchWithProxy(url) { const proxyUrl = `${MY_PRIVATE_PROXY}/?url=${encodeURIComponent(url)}`; try { const response = await fetch(proxyUrl, { signal: AbortSignal.timeout(20000) }); if (!response.ok) throw new Error(`рдкреНрд░реЙрдХреНрд╕реА рд╕рд░реНрд╡рд░ рд╕реЗ рдЬрд╡рд╛рдм рдирд╣реАрдВ рдорд┐рд▓рд╛ (рд╕реНрдЯреЗрдЯрд╕: ${response.status})`); return await response.text(); } catch (error) { if (error.name === 'AbortError' || error.name === 'TimeoutError') { throw new Error('рдЕрдиреБрд░реЛрдз рдореЗрдВ рдмрд╣реБрдд рдЕрдзрд┐рдХ рд╕рдордп рд▓рдЧрд╛ (рдЯрд╛рдЗрдордЖрдЙрдЯ)ред'); } throw error; } }

    async function createStoryElement(article, sourceUrl, originalDoc) {
        const storyDiv = document.createElement('div');
        storyDiv.className = 'single-story';
        storyDiv.dataset.textContentForSearch = (article.textContent || "").toLowerCase();
        storyDiv.dataset.sourceUrl = sourceUrl;
        storyDiv.dataset.siteName = article.siteName || new URL(sourceUrl).hostname;

        const articleDataForStorage = {
            title: article.title || "рд╢реАрд░реНрд╖рдХ рдЙрдкрд▓рдмреНрдз рдирд╣реАрдВ",
            content: article.content || "",
            textContent: article.textContent || "",
            byline: article.byline || "рдЙрдкрд▓рдмреНрдз рдирд╣реАрдВ",
            url: sourceUrl,
            length: article.length,
            excerpt: article.excerpt,
            siteName: article.siteName
        };
        storyDiv.dataset.articleData = JSON.stringify(articleDataForStorage);

        const videoContainer = document.createElement('div');
        videoContainer.className = 'video-container';
        if (originalDoc) {
            originalDoc.querySelectorAll('iframe[src*="youtube.com"], iframe[src*="vimeo.com"]').forEach(iframe => {
                const videoWrapper = document.createElement('div');
                videoWrapper.className = 'video-wrapper';
                const clonedIframe = iframe.cloneNode(true);
                clonedIframe.removeAttribute('width');
                clonedIframe.removeAttribute('height');
                videoWrapper.appendChild(clonedIframe);
                videoContainer.appendChild(videoWrapper);
            });
            originalDoc.querySelectorAll('video').forEach(video => {
                const videoWrapper = document.createElement('div');
                videoWrapper.className = 'video-wrapper';
                const clonedVideo = video.cloneNode(true);
                clonedVideo.setAttribute('controls', 'true');
                videoWrapper.appendChild(clonedVideo);
                videoContainer.appendChild(videoWrapper);
            });
        }

        const headerDiv = document.createElement('div');
        headerDiv.className = 'story-header';
        const titleH3 = document.createElement('h3');
        titleH3.textContent = article.title || "рд╢реАрд░реНрд╖рдХ рдЙрдкрд▓рдмреНрдз рдирд╣реАрдВ";
        const headerButtons = document.createElement('div');
        headerButtons.className = 'header-buttons';

        const listenBtn = document.createElement('button');
        listenBtn.textContent = 'тЦ╢я╕П рд╕реБрдиреЗрдВ';
        listenBtn.title = 'рдЖрд░реНрдЯрд┐рдХрд▓ рд╕реБрдиреЗрдВ';
        listenBtn.onclick = async () => {
            await clearQueue();
            const dataFromElement = JSON.parse(storyDiv.dataset.articleData);
            await addToQueue(dataFromElement);
        };

        const mp3Btn = document.createElement('button');
        mp3Btn.innerHTML = 'ЁЯЧгя╕П MP3';
        mp3Btn.title = 'MP3 рдСрдбрд┐рдпреЛ рдбрд╛рдЙрдирд▓реЛрдб рдХрд░реЗрдВ';
        mp3Btn.onclick = (e) => { if (!article.textContent) { showToast("MP3 рдмрдирд╛рдиреЗ рдХреЗ рд▓рд┐рдП рдЯреЗрдХреНрд╕реНрдЯ рдЙрдкрд▓рдмреНрдз рдирд╣реАрдВ рд╣реИред", "error"); return; } downloadTextAsMp3(article.textContent, article.title || "audio", e.currentTarget); };

        const saveBtn = document.createElement('button');
        saveBtn.className = 'save-btn';
        const isArticleSaved = await isSaved(sourceUrl);
        saveBtn.innerHTML = isArticleSaved ? 'тЭдя╕П рд╕реЗрд╡ рд╣реИ' : 'ЁЯдН рд╕реЗрд╡ рдХрд░реЗрдВ';
        saveBtn.title = isArticleSaved ? 'рд▓рд╛рдЗрдмреНрд░реЗрд░реА рд╕реЗ рд╣рдЯрд╛рдПрдВ' : 'рд▓рд╛рдЗрдмреНрд░реЗрд░реА рдореЗрдВ рд╕реЗрд╡ рдХрд░реЗрдВ';
        if (isArticleSaved) saveBtn.classList.add('saved');
        saveBtn.onclick = () => toggleSaveArticle(articleDataForStorage, sourceUrl, saveBtn);

        const copyBtn = document.createElement('button');
        copyBtn.innerHTML = 'ЁЯУД рдХреЙрдкреА';
        copyBtn.title = 'рдЖрд░реНрдЯрд┐рдХрд▓ (рдмрд┐рдирд╛ URLs рдХреЗ) рдХреЙрдкреА рдХрд░реЗрдВ';
        copyBtn.onclick = () => copyArticleContent(articleDataForStorage);

        const shareBtn = document.createElement('button');
        shareBtn.innerHTML = 'ЁЯФЧ рд╢реЗрдпрд░';
        shareBtn.title = 'рдЖрд░реНрдЯрд┐рдХрд▓ (рдмрд┐рдирд╛ URLs рдХреЗ) рд╢реЗрдпрд░ рдХрд░реЗрдВ';
        shareBtn.style.backgroundColor = 'var(--success-color)';
        shareBtn.onclick = () => shareLibraryArticle(articleDataForStorage);

        const originalViewBtn = document.createElement('button');
        originalViewBtn.className = 'original-view-btn';
        originalViewBtn.innerHTML = 'ЁЯМР рдУрд░рд┐рдЬрд┐рдирд▓ рдЯреИрдм';
        originalViewBtn.title = 'рдУрд░рд┐рдЬрд┐рдирд▓ рд╡реЗрдмрдкреЗрдЬ рдирдП рдЯреИрдм рдореЗрдВ рджреЗрдЦреЗрдВ';
        originalViewBtn.onclick = (e) => toggleOriginalWebViewInExtractor(e.target.closest('.single-story'), sourceUrl);

        const moreOptionsBtn = document.createElement('button');
        moreOptionsBtn.innerHTML = 'тЛо';
        moreOptionsBtn.title = 'рдФрд░ рд╡рд┐рдХрд▓реНрдк';
        moreOptionsBtn.style.fontSize = '1.2em';
        moreOptionsBtn.onclick = (e) => { e.stopPropagation(); showItemContextMenu(e.currentTarget, articleDataForStorage); };

        headerButtons.append(listenBtn, mp3Btn, saveBtn, copyBtn, shareBtn, originalViewBtn, moreOptionsBtn);
        headerDiv.append(titleH3, headerButtons);
        const wordCount = article.textContent ? article.textContent.split(/\s+/).filter(Boolean).length : 0;
        const readingTime = Math.ceil(wordCount / 200);
        const authorP = document.createElement('p');
        authorP.innerHTML = `<em style="font-size: 0.9em;">рд▓реЗрдЦрдХ: ${article.byline || 'рдЙрдкрд▓рдмреНрдз рдирд╣реАрдВ'} | рдкрдврд╝рдиреЗ рдХрд╛ рд╕рдордп: ~${readingTime} рдорд┐рдирдЯ</em>`;

        const readingProgressContainer = document.createElement('div');
        readingProgressContainer.className = 'extractor-reading-progress-container reading-progress-container';
        const readingProgressBar = document.createElement('div');
        readingProgressBar.className = 'extractor-reading-progress-bar reading-progress-bar';
        readingProgressContainer.appendChild(readingProgressBar);

        const contentDiv = document.createElement('div');
        contentDiv.className = 'article-body-content';
        if (article.content) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = article.content;
            const displayMode = await dbprefs.get('displayMode', 'image-text');
            if (displayMode === 'text-only') {
                tempDiv.querySelectorAll('img, figure, picture').forEach(el => el.remove());
            } else {
                tempDiv.querySelectorAll('img').forEach(img => {
                    const originalSrc = img.getAttribute('src') || img.dataset.src;
                    if (originalSrc) {
                        try { img.src = new URL(originalSrc, sourceUrl).href; } catch (e) { console.warn("Invalid image URL:", originalSrc); }
                    }
                    img.loading = 'lazy';
                });
            }
            tempDiv.querySelectorAll('a[href]').forEach(linkElement => {
                const originalHref = linkElement.getAttribute('href');
                if (originalHref && !originalHref.startsWith('#') && !originalHref.startsWith('javascript:')) {
                    try {
                        const absoluteUrl = new URL(originalHref, sourceUrl).href;
                        linkElement.style.cssText = 'color: var(--primary-color); text-decoration: underline; cursor: pointer;';
                        linkElement.title = `рд░реАрдбрд░ рдореЗрдВ рдЦреЛрд▓реЗрдВ: ${absoluteUrl.substring(0,70)}...`;
                        linkElement.setAttribute('data-reader-target-url', absoluteUrl);
                        linkElement.href = 'javascript:void(0);';
                        linkElement.removeAttribute('target');
                    } catch (e) {
                        linkElement.target = '_blank';
                        linkElement.rel = 'noopener noreferrer';
                    }
                }
            });
            contentDiv.innerHTML = tempDiv.innerHTML;
        } else {
            contentDiv.innerHTML = "<p><em>рдЗрд╕ рдЖрд░реНрдЯрд┐рдХрд▓ рдХрд╛ рдХрдВрдЯреЗрдВрдЯ рд▓реЛрдб рдирд╣реАрдВ рд╣реЛ рд╕рдХрд╛ред</em></p>";
        }

        contentDiv.addEventListener('scroll', function() {
            if (this.scrollHeight > this.clientHeight) {
                const scrollPercent = this.scrollTop / (this.scrollHeight - this.clientHeight);
                const progress = Math.min(1, Math.max(0, scrollPercent)) * 100;
                readingProgressBar.style.width = `${progress}%`;
                readingProgressContainer.style.display = 'block';
            } else {
                readingProgressContainer.style.display = 'none';
            }
        });
        setTimeout(() => { 
             if (contentDiv.scrollHeight > contentDiv.clientHeight) {
                readingProgressContainer.style.display = 'block';
             } else {
                readingProgressContainer.style.display = 'none';
             }
        }, 100);

        storyDiv.innerHTML = '';
        storyDiv.append(headerDiv, authorP);
        if (videoContainer.hasChildNodes()) {
            storyDiv.append(videoContainer);
        }
        storyDiv.append(readingProgressContainer, document.createElement('hr'), contentDiv);

        const playAllBtn = document.getElementById('playAllExtractedBtn');
        if (playAllBtn && playAllBtn.style.display === 'none' && document.querySelectorAll('#ae_result .single-story').length >=0 ) {
            playAllBtn.style.display = 'inline-block';
        }
        return storyDiv;
    }

    function toggleOriginalWebViewInExtractor(storyElement, articleUrl) {
        if (!articleUrl) return;
        window.open(articleUrl, '_blank', 'noopener,noreferrer');
    }


    async function copyArticleContent(articleData) {
        if (!articleData || !articleData.title || !articleData.textContent) {
            showToast('рдХреЙрдкреА рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдЖрд╡рд╢реНрдпрдХ рдбреЗрдЯрд╛ рдирд╣реАрдВ рдорд┐рд▓рд╛ред', 'error');
            return;
        }
        const filteredTextContent = removeUrlsFromText(articleData.textContent);
        const textToCopy = `рд╢реАрд░реНрд╖рдХ: ${articleData.title}\n\n${filteredTextContent}`;

        try {
            if (navigator.clipboard && window.isSecureContext) {
                await navigator.clipboard.writeText(textToCopy);
                showToast('рдЖрд░реНрдЯрд┐рдХрд▓ рдЯреЗрдХреНрд╕реНрдЯ (рдмрд┐рдирд╛ URLs рдХреЗ) рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдХреЙрдкреА рд╣реБрдЖ!', 'success');
            } else {
                const textArea = document.createElement('textarea');
                textArea.value = textToCopy;
                textArea.style.position = 'fixed';
                textArea.style.opacity = '0';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    const successful = document.execCommand('copy');
                    if (successful) {
                        showToast('рдЖрд░реНрдЯрд┐рдХрд▓ рдЯреЗрдХреНрд╕реНрдЯ (рдмрд┐рдирд╛ URLs рдХреЗ) рдХреЙрдкреА рд╣реБрдЖ (fallback)!', 'success');
                    } else {
                        throw new Error('Fallback copy command failed.');
                    }
                } catch (err) {
                    console.error('Fallback copy error:', err);
                    showToast('рдХреЙрдкреА рд╡рд┐рдлрд▓ред рдмреНрд░рд╛рдЙрдЬрд╝рд░ рдиреЗ рдЕрдиреБрдорддрд┐ рдирд╣реАрдВ рджреАред рдореИрдиреНрдпреБрдЕрд▓ рд░реВрдк рд╕реЗ рдХреЙрдкреА рдХрд░реЗрдВред', 'error', 5000);
                    displayFallbackShareOptions({text: textToCopy, title: articleData.title}, true);
                }
                document.body.removeChild(textArea);
            }
        } catch (err) {
            console.error('рдХреЙрдкреА рдХрд░рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ (рдореБрдЦреНрдп рдкреНрд░рдпрд╛рд╕):', err);
            showToast('рдХреЙрдкреА рд╡рд┐рдлрд▓ред рдмреНрд░рд╛рдЙрдЬрд╝рд░ рдиреЗ рдЕрдиреБрдорддрд┐ рдирд╣реАрдВ рджреА рдпрд╛ рдХреЛрдИ рддреНрд░реБрдЯрд┐ рд╣реБрдИред', 'error', 5000);
        }
    }


    async function playAllExtractedArticles() {
        const resultDiv = document.getElementById('ae_result');
        const storyElements = resultDiv.querySelectorAll('.single-story');

        if (storyElements.length === 0) {
            showToast("рдкреНрд▓реЗ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдХреЛрдИ рдЖрд░реНрдЯрд┐рдХрд▓ рдирд╣реАрдВ рдорд┐рд▓рд╛ред", "warning");
            return;
        }

        const articleUrlsToProcess = [];
        storyElements.forEach(storyEl => {
            try {
                const articleData = JSON.parse(storyEl.dataset.articleData);
                if (articleData && articleData.url) {
                    articleUrlsToProcess.push(articleData.url);
                }
            } catch(e) {
                console.warn("Could not get URL from story element:", storyEl, e);
            }
        });

        if (articleUrlsToProcess.length === 0) {
            showToast("рдкреНрд▓реЗ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдХреЛрдИ рд╡реИрдз рдЖрд░реНрдЯрд┐рдХрд▓ URL рдирд╣реАрдВ рдорд┐рд▓рд╛ред", "error");
            return;
        }

        await clearQueue();
        showToast(`рд╕рднреА ${articleUrlsToProcess.length} рдЖрд░реНрдЯрд┐рдХрд▓ рдХреЛ рдкреНрд░реЛрд╕реЗрд╕ рдХрд┐рдпрд╛ рдЬрд╛ рд░рд╣рд╛ рд╣реИ... рдХреГрдкрдпрд╛ рдкреНрд░рддреАрдХреНрд╖рд╛ рдХрд░реЗрдВред`, "info", articleUrlsToProcess.length * 2000);

        let articlesAddedToQueueCount = 0;
        const playAllBtn = document.getElementById('playAllExtractedBtn');
        const originalBtnText = playAllBtn.innerHTML;
        playAllBtn.innerHTML = 'рдкреНрд░реЛрд╕реЗрд╕рд┐рдВрдЧ...';
        playAllBtn.disabled = true;

        for (let i = 0; i < articleUrlsToProcess.length; i++) {
            const url = articleUrlsToProcess[i];
            showToast(`рдЖрд░реНрдЯрд┐рдХрд▓ ${i + 1}/${articleUrlsToProcess.length} рд▓реЛрдб рд╣реЛ рд░рд╣рд╛ рд╣реИ: ${url.substring(0,30)}...`, "info", 3000);
            try {
                const html = await fetchWithProxy(url);
                const doc = new DOMParser().parseFromString(html, "text/html");
                const baseEl = doc.createElement('base');
                baseEl.href = url;
                doc.head.appendChild(baseEl);

                const readableArticle = new Readability(doc.cloneNode(true)).parse();

                if (readableArticle && readableArticle.textContent && readableArticle.title) {
                    await addToQueue({
                        title: readableArticle.title,
                        textContent: readableArticle.textContent,
                        content: readableArticle.content,
                        byline: readableArticle.byline,
                        url: url,
                        siteName: readableArticle.siteName
                    });
                    articlesAddedToQueueCount++;
                } else {
                    console.warn(`рдЖрд░реНрдЯрд┐рдХрд▓ ${url} рд╕реЗ рдХрдВрдЯреЗрдВрдЯ рдирд╣реАрдВ рдирд┐рдХрд╛рд▓рд╛ рдЬрд╛ рд╕рдХрд╛ред`);
                    showToast(`рдЖрд░реНрдЯрд┐рдХрд▓ ${url.substring(0,30)}... рд╕реЗ рдХрдВрдЯреЗрдВрдЯ рдирд╣реАрдВ рдирд┐рдХрд╛рд▓рд╛ рдЬрд╛ рд╕рдХрд╛ред`, "warning", 2000);
                }
            } catch (error) {
                console.error(`рдЖрд░реНрдЯрд┐рдХрд▓ ${url} рдХреЛ рдкреНрд░реЛрд╕реЗрд╕ рдХрд░рдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐:`, error);
                showToast(`рдЖрд░реНрдЯрд┐рдХрд▓ ${url.substring(0,30)}... рдХреЛ рдкреНрд░реЛрд╕реЗрд╕ рдХрд░рдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐ред`, "error", 2000);
            }
            if (articlesAddedToQueueCount > 0 && articlesAddedToQueueCount % 5 === 0) {
                 await new Promise(resolve => setTimeout(resolve, 50));
            }
        }

        playAllBtn.innerHTML = originalBtnText;
        playAllBtn.disabled = false;

        if (articlesAddedToQueueCount > 0) {
            startQueuePlayback();
            showToast(`${articlesAddedToQueueCount} рдЖрд░реНрдЯрд┐рдХрд▓ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдХреНрдпреВ рдореЗрдВ рдЬреЛрдбрд╝реЗ рдЧрдП рдФрд░ рдкреНрд▓реЗрдмреИрдХ рд╢реБрд░реВ рд╣реБрдЖ!`, "success");
            openTool(null, 'MyLibrary');
        } else {
            showToast("рдХреЛрдИ рднреА рдЖрд░реНрдЯрд┐рдХрд▓ рдкреНрд▓реЗрдмреИрдХ рдХреЗ рд▓рд┐рдП рдХреНрдпреВ рдореЗрдВ рдирд╣реАрдВ рдЬреЛрдбрд╝рд╛ рдЬрд╛ рд╕рдХрд╛ред", "error");
        }
    }


    document.addEventListener('click', function(event) { let targetElement = event.target.closest('a[data-reader-target-url]'); if (targetElement && document.getElementById('ae_result').contains(targetElement)) { event.preventDefault(); event.stopPropagation(); const urlToLoad = targetElement.getAttribute('data-reader-target-url'); showToast(`рдЖрдВрддрд░рд┐рдХ рд▓рд┐рдВрдХ рд▓реЛрдб рд╣реЛ рд░рд╣рд╛ рд╣реИ...`, 'info'); document.getElementById('articleUrl').value = urlToLoad; document.getElementById('crawlSiteToggle').checked = false; if (!isNavigatingHistory) addToHistory(urlToLoad); ae_startExtraction(true); window.scrollTo(0,0); } });
    async function downloadTextAsMp3(text, filename, btn) { const originalText = btn ? btn.innerHTML : ''; if (btn) { btn.innerHTML = 'рдкреНрд░реЛрд╕реЗрд╕рд┐рдВрдЧ...'; btn.disabled = true; } showToast('MP3 рдирд┐рд░реНрдорд╛рдг рд╢реБрд░реВ рд╣реЛ рд░рд╣рд╛ рд╣реИ...', 'info'); const cleanedText = (text || "").replace(/\s+/g, ' ').trim(); if (!cleanedText) { showToast('MP3 рдмрдирд╛рдиреЗ рдХреЗ рд▓рд┐рдП рдХреЛрдИ рдЯреЗрдХреНрд╕реНрдЯ рдирд╣реАрдВ рд╣реИред', 'error'); if (btn) { btn.innerHTML = originalText; btn.disabled = false; } return; } const chunks = cleanedText.match(/.{1,180}/g) || [cleanedText]; const audioBlobs = []; try { for (let i = 0; i < chunks.length; i++) { if (btn) btn.innerHTML = `рднрд╛рдЧ ${i+1}/${chunks.length}...`; const ttsUrl = `https://translate.google.com/translate_tts?ie=UTF-8&q=${encodeURIComponent(chunks[i])}&tl=hi&client=tw-ob`; const audioResponse = await fetch(`${MY_PRIVATE_PROXY}/?url=${encodeURIComponent(ttsUrl)}`, { signal: AbortSignal.timeout(20000) }); if (!audioResponse.ok) throw new Error(`TTS API рддреНрд░реБрдЯрд┐ (рд╕реНрдЯреЗрдЯрд╕: ${audioResponse.status})`); const blob = await audioResponse.blob(); if (blob.size === 0 || !blob.type.startsWith('audio/')) throw new Error('рдЕрдорд╛рдиреНрдп рдСрдбрд┐рдпреЛ рдбреЗрдЯрд╛'); audioBlobs.push(blob); } const combinedBlob = new Blob(audioBlobs, { type: 'audio/mpeg' }); const downloadUrl = URL.createObjectURL(combinedBlob); const a = document.createElement('a'); a.href = downloadUrl; const safeFilename = (filename || "audio").replace(/[^a-z0-9\u0900-\u097F\s._-]/gi, '_').replace(/\s+/g, '_'); a.download = `${safeFilename}.mp3`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(downloadUrl); showToast("MP3 рдбрд╛рдЙрдирд▓реЛрдб рд╢реБрд░реВ!", "success"); } catch (error) { showToast(`MP3 рддреНрд░реБрдЯрд┐: ${error.message}`, 'error', 7000); } finally { if (btn) { btn.innerHTML = originalText; btn.disabled = false; } } }
    async function ae_startExtraction(isNavigationAction = false) { await stopTTS(); const urlInput = document.getElementById('articleUrl').value.trim(); const loadingDiv = document.getElementById('ae_loading'); const resultDiv = document.getElementById('ae_result'); if (!urlInput) { showToast('рдХреГрдкрдпрд╛ рдПрдХ URL рдбрд╛рд▓реЗрдВред', 'error'); return; } let initialUrlObj; try { initialUrlObj = new URL(urlInput); } catch (_) { showToast('рдЕрдорд╛рдиреНрдп URL.', 'error'); return; } if (!isNavigatingHistory && !isNavigationAction) { addToHistory(initialUrlObj.href); } loadingDiv.style.display = 'block'; resultDiv.innerHTML = ''; allFoundLinks = new Set(); currentProcessIndex = 0; isProcessing = false; try { loadingDiv.innerText = "рдкреЗрдЬ рдХрд╛ рд╡рд┐рд╢реНрд▓реЗрд╖рдг..."; const shouldCrawl = !isNavigationAction && document.getElementById('crawlSiteToggle').checked; const html = await fetchWithProxy(initialUrlObj.href); const doc = new DOMParser().parseFromString(html, "text/html"); const base = new URL(initialUrlObj.href); const article = new Readability(doc.cloneNode(true)).parse(); if (article && article.content && article.title) { resultDiv.appendChild(await createStoryElement(article, initialUrlObj.href, doc)); allFoundLinks.add(initialUrlObj.href); } else { console.warn("Readability failed or insufficient content for:", initialUrlObj.href, article); if (resultDiv.innerHTML === '') { resultDiv.innerHTML = `<p>рдЗрд╕ URL рд╕реЗ рдЖрд░реНрдЯрд┐рдХрд▓ рдХрдВрдЯреЗрдВрдЯ рдирд╣реАрдВ рдирд┐рдХрд╛рд▓рд╛ рдЬрд╛ рд╕рдХрд╛: <a href="${initialUrlObj.href}" target="_blank" rel="noopener noreferrer">${initialUrlObj.href}</a>. рдХреГрдкрдпрд╛ рдореВрд▓ рд▓рд┐рдВрдХ рдкрд░ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред</p>`;} } if (shouldCrawl) { loadingDiv.innerText = "рд╕рдВрдмрдВрдзрд┐рдд рд▓реЗрдЦреЛрдВ рдХреЗ рд▓рд┐рдП рд▓рд┐рдВрдХреНрд╕ рдЦреЛрдЬ рд░рд╣рд╛ рд╣реИ..."; const linksToProcess = new Set(); doc.querySelectorAll('a[href]').forEach(a => { try { const href = a.getAttribute('href'); if (!href || href.startsWith('#') || href.startsWith('javascript:')) return; const absoluteUrl = new URL(href, base.href); if (absoluteUrl.hostname === base.hostname) { linksToProcess.add(absoluteUrl.href.split('#')[0]); } } catch (e) {} }); const initialSize = allFoundLinks.size; allFoundLinks = new Set([...allFoundLinks, ...linksToProcess]); if (allFoundLinks.size > initialSize || (allFoundLinks.size === 0 && linksToProcess.size > 0 && (!article || !article.content)) ) { await processNextLink(); } else { loadingDiv.style.display = 'none'; if (resultDiv.innerHTML === '' && (!article || !article.content)) { resultDiv.innerHTML = `<p>рдХреЛрдИ рдкрдардиреАрдп рдЖрд░реНрдЯрд┐рдХрд▓ рдирд╣реАрдВ рдорд┐рд▓рд╛ред</p>`; } } } else { loadingDiv.style.display = 'none'; if (!article || !article.content && resultDiv.innerHTML === '') { resultDiv.innerHTML = `<p>рдЗрд╕ URL рд╕реЗ рдЖрд░реНрдЯрд┐рдХрд▓ рдирд╣реАрдВ рдирд┐рдХрд╛рд▓рд╛ рдЬрд╛ рд╕рдХрд╛ред</p>`; } } } catch (error) { resultDiv.innerHTML = `<p>рддреНрд░реБрдЯрд┐: ${error.message}</p>`; showToast(`рддреНрд░реБрдЯрд┐: ${error.message}`, 'error'); loadingDiv.style.display = 'none'; } }
    async function processNextLink() { if (isProcessing) return; const linksArray = Array.from(allFoundLinks); if (currentProcessIndex >= linksArray.length) { document.getElementById('ae_loading').style.display = 'none'; if(document.getElementById('ae_result').innerHTML === '') { document.getElementById('ae_result').innerHTML = `<p>рдХреЛрдИ рдкрдардиреАрдп рдЖрд░реНрдЯрд┐рдХрд▓ рдирд╣реАрдВ рдорд┐рд▓рд╛ред</p>`; } return; } const link = linksArray[currentProcessIndex]; if (currentProcessIndex === 0 && document.querySelector('#ae_result .single-story')) { currentProcessIndex++; await processNextLink(); return; } isProcessing = true; const loadingDiv = document.getElementById('ae_loading'); loadingDiv.innerText = `рдЖрд░реНрдЯрд┐рдХрд▓ (${currentProcessIndex + 1}/${linksArray.length}) рд▓реЛрдб рд╣реЛ рд░рд╣рд╛ рд╣реИ: ${link.substring(0,50)}...`; try { const html = await fetchWithProxy(link); const doc = new DOMParser().parseFromString(html, "text/html"); doc.head.insertAdjacentHTML('beforeend', `<base href="${link}">`); const article = new Readability(doc.cloneNode(true), {charThreshold: 500}).parse(); if (article && article.content && article.title) { document.getElementById('ae_result').appendChild(await createStoryElement(article, link, doc)); } else {console.warn("Readability failed or insufficient content for (crawled):", link, article);} } catch (e) { console.warn(`Could not process article from ${link}: ${e.message}`); } finally { currentProcessIndex++; isProcessing = false; setTimeout(processNextLink, 50); } }
    function toggleDepthSelector() { document.getElementById('depthSelectorContainer').style.display = document.getElementById('crawlSiteToggle').checked ? 'inline-block' : 'none'; }
    async function clearResults() { await stopTTS(); document.getElementById('ae_result').innerHTML = ''; document.getElementById('articleUrl').value = ''; allFoundLinks.clear(); currentProcessIndex = 0; navigationHistory = []; currentHistoryIndex = -1; updateHistoryButtons(); showToast("рдкрд░рд┐рдгрд╛рдо рд╕рд╛рдлрд╝ред"); hideAudioPlayer(); audioPlayerState.currentArticle = null; const playAllBtn = document.getElementById('playAllExtractedBtn'); if (playAllBtn) { playAllBtn.style.display = 'none'; } }
    function clearUrlInput() { const i = document.getElementById('articleUrl'); i.value = ''; i.focus(); }
    function filterExtractedArticles() { const term = document.getElementById('extractorSearch').value.toLowerCase(); document.querySelectorAll('.single-story').forEach(div => { const text = (div.textContent || "").toLowerCase(); div.style.display = text.includes(term) ? 'block' : 'none'; }); }
    function clearExtractorSearch() { const i = document.getElementById('extractorSearch'); i.value = ''; filterExtractedArticles(); }
    
    async function isSaved(url) { return (await db.articles.get(url)) !== undefined; }
    
    async function toggleSaveArticle(articleData, url, btn) {
        const existingArticle = await db.articles.get(url);
        if (existingArticle) {
            await db.articles.delete(url);
            btn.innerHTML = 'ЁЯдН рд╕реЗрд╡ рдХрд░реЗрдВ'; btn.classList.remove('saved');
        } else {
            let finalArticleData = { 
                ...articleData, 
                savedAt: new Date().toISOString(), 
                tags: [], 
                isRead: false, 
                notes: "",
                collectionId: "uncategorized",
                siteName: articleData.siteName || new URL(url).hostname
            };
            finalArticleData = await applyAutomationRules(finalArticleData);
            await db.articles.put(finalArticleData);
            btn.innerHTML = 'тЭдя╕П рд╕реЗрд╡ рд╣реИ'; btn.classList.add('saved');
        }
        await updateLibraryCount();
        await populateTagFilter();
    }
    
    async function toggleReadStatus(url, isRead) { await db.articles.update(url, { isRead: isRead }); }

    async function loadLibrary() {
        const listDiv = document.getElementById('library-list');
        const searchTerm = document.getElementById('librarySearch').value.toLowerCase();
        const sortOrder = document.getElementById('librarySort').value;
        const selectedTag = document.getElementById('libraryTagFilter')?.value || "";
        const selectedCollectionId = document.getElementById('libraryCollectionFilter')?.value || "";
        const selectedReadStatus = document.getElementById('libraryReadStatusFilter')?.value || "all";
        
        const clearFiltersBtn = document.getElementById('clearLibraryFiltersBtn');
        if (clearFiltersBtn) { clearFiltersBtn.style.display = (searchTerm || selectedTag || selectedReadStatus !== 'all' || selectedCollectionId) ? 'inline-block' : 'none'; }

        let query = db.articles;

        // --- Filtering ---
        if (selectedCollectionId) {
            query = query.where('collectionId').equals(selectedCollectionId);
        }
        if (selectedTag) {
            query = query.where('tags').equals(selectedTag);
        }
        if (selectedReadStatus === "read") {
            query = query.where('isRead').equals(true);
        } else if (selectedReadStatus === "unread") {
            query = query.where('isRead').equals(false);
        }

        // --- Sorting ---
        if (sortOrder === 'title_asc') {
            query = query.orderBy('title');
        } else if (sortOrder === 'title_desc') {
            query = query.orderBy('title').reverse();
        } else if (sortOrder === 'date_asc') {
            query = query.orderBy('savedAt');
        } else { // date_desc is default
            query = query.orderBy('savedAt').reverse();
        }

        let itemsArray = await query.toArray();

        // Full-text search (performed after initial filtering for performance)
        if (searchTerm) {
            itemsArray = itemsArray.filter(item => 
                (item.title?.toLowerCase().includes(searchTerm) || item.textContent?.toLowerCase().includes(searchTerm))
            );
        }

        listDiv.innerHTML = '';
        if (itemsArray.length === 0) {
            listDiv.innerHTML = '<p>рд▓рд╛рдЗрдмреНрд░реЗрд░реА рдЦрд╛рд▓реА рд╣реИ рдпрд╛ рдХреЛрдИ рдкрд░рд┐рдгрд╛рдо рдирд╣реАрдВ рдорд┐рд▓рд╛ред</p>';
        } else {
            itemsArray.forEach(itemData => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'library-item';
                itemDiv.id = `lib-item-${btoa(encodeURIComponent(itemData.url))}`;
                itemDiv.innerHTML = ` <input type="checkbox" class="playlist-checkbox" data-url="${itemData.url}" onchange="updatePlaylistControls()" title="рдмреИрдЪ рдСрдкрд░реЗрд╢рди рдХреЗ рд▓рд┐рдП рдЪреБрдиреЗрдВ"> <span class="item-title">${itemData.title || "N/A"}</span> <div class="item-controls"> <span class="read-status-toggle" title="${itemData.isRead ? 'рдЕрдкрдард┐рдд рдХрд░реЗрдВ' : 'рдкрдврд╝рд╛ рдХрд░реЗрдВ'}">${itemData.isRead ? 'тЬЕ' : 'ЁЯУЦ'}</span> <button class="item-more-options-btn">тЛо</button> <button class="delete-btn">рд╣рдЯрд╛рдПрдБ</button> </div> `;
                itemDiv.querySelector('.item-title').onclick = async () => {
                    const existingQueueIndex = playQueue.findIndex(pqItem => pqItem.url === itemData.url);
                    if (existingQueueIndex !== -1 && (isPlaying || isPaused) && audioPlayerState.currentArticle?.url === itemData.url) {
                        await showSavedArticle(itemData);
                    } else if (existingQueueIndex !== -1) {
                        await playQueueItem(existingQueueIndex);
                    } else {
                        await clearQueue();
                        await addToQueue(itemData);
                    }
                };
                itemDiv.querySelector('.read-status-toggle').onclick = async (e) => { e.stopPropagation(); await toggleReadStatus(itemData.url, !itemData.isRead); await loadLibrary(); };
                itemDiv.querySelector('.delete-btn').onclick = (e) => { e.stopPropagation(); deleteLibraryItem(itemData.url); };
                itemDiv.querySelector('.item-more-options-btn').onclick = (e) => { e.stopPropagation(); showItemContextMenu(e.currentTarget, itemData); };
                listDiv.appendChild(itemDiv);
            });
        }
        updatePlaylistControls();
    }


    function showItemContextMenu(button, articleData) { document.querySelectorAll('.item-context-menu').forEach(menu => menu.remove()); const menu = document.createElement('div'); menu.className = 'item-context-menu'; menu.innerHTML = ` <button class="play-next-btn">тЦ╢я╕П рдЕрдЧрд▓рд╛ рдЪрд▓рд╛рдПрдВ</button> <button class="add-to-queue-btn">тПпя╕П рдХреНрдпреВ рдореЗрдВ рдЬреЛрдбрд╝реЗрдВ</button> `; document.body.appendChild(menu); menu.querySelector('.play-next-btn').addEventListener('click', async () => { await addToQueue(articleData, true); menu.remove(); }); menu.querySelector('.add-to-queue-btn').addEventListener('click', async () => { await addToQueue(articleData, false); menu.remove(); }); const rect = button.getBoundingClientRect(); const menuHeight = menu.offsetHeight; const menuWidth = menu.offsetWidth; let top = rect.bottom; let left = rect.right - menuWidth; if (top + menuHeight > window.innerHeight) { top = rect.top - menuHeight; } if (left < 0) { left = rect.left; } menu.style.top = `${top + window.scrollY}px`; menu.style.left = `${left + window.scrollX}px`; menu.style.display = 'block'; setTimeout(() => { document.addEventListener('click', () => menu.remove(), { once: true }); }, 0); }
    async function deleteLibraryItem(url) { if(!confirm('рдХреНрдпрд╛ рдЖрдк рд╡рд╛рдХрдИ рдЗрд╕ рдЖрд░реНрдЯрд┐рдХрд▓ рдХреЛ рд╣рдЯрд╛рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ?')) return; await db.articles.delete(url); await loadLibrary(); await updateLibraryCount(); const view = document.getElementById('library-article-view'); if (view && view.dataset.currentArticleUrl === url) { view.style.display = 'none'; view.dataset.hasContent = 'false'; hideAudioPlayer(); if(audioPlayerState.currentArticle && audioPlayerState.currentArticle.url === url) { await stopTTS(); audioPlayerState.currentArticle = null; } } showToast("рд╣рдЯрд╛рдпрд╛ рдЧрдпрд╛ред"); }
    async function clearLibraryFilters() { document.getElementById('librarySearch').value = ''; document.getElementById('libraryTagFilter').value = ''; document.getElementById('libraryCollectionFilter').value = ''; document.getElementById('libraryReadStatusFilter').value = 'all'; await loadLibrary(); showToast("рд╕рднреА рдлрд╝рд┐рд▓реНрдЯрд░ рд╕рд╛рдлрд╝ред"); }
    async function showSavedArticle(articleData) {
        const view = document.getElementById('library-article-view');
        const textEl = document.getElementById('lib-article-text-content');
        const libProgressBarContainer = document.getElementById('library-reading-progress-container');
        const libProgressBar = document.getElementById('library-reading-progress-bar');
        const notesContainer = document.getElementById('lib-article-notes-container');
        const notesTextarea = document.getElementById('lib-article-notes');
        const collectionSelect = document.getElementById('libArticleCollection');


        document.getElementById('lib-article-title').textContent = articleData.title;
        document.getElementById('lib-article-original-url').href = articleData.url;
        document.getElementById('lib-article-original-url').textContent = articleData.url.substring(0, 60) + '...';
        textEl.textContent = articleData.textContent || "рдЯреЗрдХреНрд╕реНрдЯ рдирд╣реАрдВ рдорд┐рд▓рд╛ред";
        document.getElementById('shareLibArticleBtn').onclick = () => shareLibraryArticle(articleData);
        const tagContainer = document.getElementById('lib-article-tags-container');
        const isLibraryArticle = await isSaved(articleData.url);
        if (isLibraryArticle) {
            tagContainer.style.display = 'block';
            notesContainer.style.display = 'block';
            collectionSelect.parentElement.style.display = 'inline-block';
            const libraryItem = await db.articles.get(articleData.url);
            displayArticleTags(articleData.url, libraryItem ? libraryItem.tags : []);
            notesTextarea.value = libraryItem ? (libraryItem.notes || "") : "";
            notesTextarea.oninput = () => handleNotesInput(articleData.url);
            collectionSelect.value = libraryItem ? (libraryItem.collectionId || 'uncategorized') : 'uncategorized';

        } else {
            tagContainer.style.display = 'none';
            notesContainer.style.display = 'none';
            collectionSelect.parentElement.style.display = 'none';
        }
        await applySavedLibraryFontSize();
        view.style.display = 'block';
        view.dataset.currentArticleUrl = articleData.url;
        view.dataset.hasContent = 'true';

        document.getElementById('audioPlayerContainer').style.display = (isPlaying || isPaused) && audioPlayerState.currentArticle?.url === articleData.url ? 'flex' : 'none';
        document.getElementById('autoScrollControls').style.display = 'flex';


        textEl.onscroll = () => {
            if (textEl.scrollHeight > textEl.clientHeight) {
                const scrollPercent = textEl.scrollTop / (textEl.scrollHeight - textEl.clientHeight);
                const progress = Math.min(1, Math.max(0, scrollPercent)) * 100;
                libProgressBar.style.width = `${progress}%`;
                libProgressBarContainer.style.display = 'block';
            } else {
                libProgressBarContainer.style.display = 'none';
            }
            clearTimeout(scrollSaveTimeout);
            scrollSaveTimeout = setTimeout(async () => {
                if (textEl.scrollHeight > textEl.clientHeight) {
                    const scrollPercentForSave = textEl.scrollTop / (textEl.scrollHeight - textEl.clientHeight);
                    if (isFinite(scrollPercentForSave) && scrollPercentForSave >= 0 && scrollPercentForSave <= 1) {
                        await saveScrollPosition(articleData.url, scrollPercentForSave);
                    }
                }
            }, 500);
        };

        libProgressBar.style.width = '0%';
        const savedScroll = await getSavedScrollPosition(articleData.url);
        if (savedScroll !== null && textEl.scrollHeight > textEl.clientHeight) {
            setTimeout(() => {
                textEl.scrollTop = savedScroll * (textEl.scrollHeight - textEl.clientHeight);
                const event = new Event('scroll');
                textEl.dispatchEvent(event);
            }, 100);
        } else {
            textEl.scrollTop = 0;
             if(textEl.scrollHeight <= textEl.clientHeight) {
                libProgressBarContainer.style.display = 'none';
            } else {
                libProgressBarContainer.style.display = 'block';
                libProgressBar.style.width = '0%';
            }
        }


        document.querySelectorAll('.library-item.selected').forEach(el => el.classList.remove('selected'));
        if (isLibraryArticle) {
            const libItemEl = document.getElementById(`lib-item-${btoa(encodeURIComponent(articleData.url))}`);
            if (libItemEl) libItemEl.classList.add('selected');
            const libEntry = await db.articles.get(articleData.url);
            if (libEntry && !libEntry.isRead) {
                 await toggleReadStatus(articleData.url, true);
            }
        }

        openTool(null, 'MyLibrary');
        document.getElementById('library-content-wrapper').scrollIntoView({ behavior: 'smooth', block: 'start' });
    }

    async function toggleOriginalWebViewForLibrary() {
        const articleUrl = document.getElementById('lib-article-original-url').href;
        if (!articleUrl || articleUrl === 'about:blank' || articleUrl === '#') {
            showToast("рдУрд░рд┐рдЬрд┐рдирд▓ URL рдирд╣реАрдВ рдорд┐рд▓рд╛ред", "error");
            return;
        }
        window.open(articleUrl, '_blank', 'noopener,noreferrer');
    }


    async function populateTagFilter() { const allTags = await db.articles.orderBy('tags').uniqueKeys(); const tags = allTags.flat().filter(Boolean); const uniqueTags = [...new Set(tags)]; const sel = document.getElementById('libraryTagFilter'); const val = sel.value; sel.innerHTML = '<option value="">рд╕рднреА рдЯреИрдЧ</option>'; uniqueTags.sort((a,b) => a.localeCompare(b,'hi')).forEach(tag => sel.innerHTML += `<option value="${tag}">${tag}</option>`); sel.value = val; }
    function displayArticleTags(url, tags) { const div = document.getElementById('lib-article-current-tags'); div.innerHTML = tags?.length ? '' : '<em>рдХреЛрдИ рдЯреИрдЧ рдирд╣реАрдВред</em>'; tags?.forEach(tag => { const span = document.createElement('span'); span.className = 'tag-item'; span.textContent = tag; const btn = document.createElement('button'); btn.className = 'tag-remove-btn'; btn.textContent = 'тЬЧ'; btn.onclick = () => removeTagFromCurrentLibraryArticle(tag); span.appendChild(btn); div.appendChild(span); }); }
    async function addTagToCurrentLibraryArticle() { const input = document.getElementById('lib-new-tag-input'); const url = document.getElementById('library-article-view').dataset.currentArticleUrl; const name = input.value.trim().toLowerCase(); if (!url || !name) return; const article = await db.articles.get(url); if (article) { const newTags = new Set(article.tags || []); newTags.add(name); await db.articles.update(url, { tags: Array.from(newTags) }); displayArticleTags(url, Array.from(newTags)); input.value = ''; await populateTagFilter(); } }
    async function removeTagFromCurrentLibraryArticle(tagName) { const url = document.getElementById('library-article-view').dataset.currentArticleUrl; if (!url || !tagName) return; const article = await db.articles.get(url); if (article?.tags) { const newTags = article.tags.filter(t => t !== tagName); await db.articles.update(url, { tags: newTags }); displayArticleTags(url, newTags); await populateTagFilter(); } }
    function handleNotesInput(url) { clearTimeout(notesSaveTimeout); notesSaveTimeout = setTimeout(() => { saveCurrentArticleNotes(url); }, 750); }
    async function saveCurrentArticleNotes(url) { const notesTextarea = document.getElementById('lib-article-notes'); if (!url) return; await db.articles.update(url, { notes: notesTextarea.value }); showToast("рдиреЛрдЯреНрд╕ рд╕рд╣реЗрдЬреЗ рдЧрдПред", "success", 1500); }

    async function copyLibraryArticleText() {
        const titleEl = document.getElementById('lib-article-title');
        const contentEl = document.getElementById('lib-article-text-content');

        if (!titleEl || !contentEl) {
            showToast('рдХреЙрдкреА рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдЖрд╡рд╢реНрдпрдХ рддрддреНрд╡ рдирд╣реАрдВ рдорд┐рд▓реЗред', 'error');
            return;
        }
        const articleDataForCopy = {
            title: titleEl.textContent,
            textContent: contentEl.textContent
        };
        await copyArticleContent(articleDataForCopy);
    }

    async function shareLibraryArticle(articleData) {
        if (!articleData || !articleData.title || !articleData.textContent) {
            showToast('рд╢реЗрдпрд░ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдЖрд╡рд╢реНрдпрдХ рдбреЗрдЯрд╛ рдирд╣реАрдВ рдорд┐рд▓рд╛ред', 'error');
            return;
        }

        const filteredTextContent = removeUrlsFromText(articleData.textContent);
        let shareText = `рд╢реАрд░реНрд╖рдХ: ${articleData.title}\n\n${filteredTextContent}`;
        if(articleData.notes) { shareText += `\n\nрдореЗрд░реЗ рдиреЛрдЯреНрд╕:\n${articleData.notes}`; }

        const dataToShare = {
            title: articleData.title,
            text: shareText,
        };
        if (articleData.url && !articleData.url.startsWith('blob:')) {
            dataToShare.url = articleData.url;
        }


        if (navigator.share) {
            try {
                await navigator.share(dataToShare);
            } catch (e) {
                console.warn("Share API error:", e);
                if (e.name !== 'AbortError') {
                    showToast('рд╢реЗрдпрд░рд┐рдВрдЧ рд╡рд┐рдлрд▓ рд╣реБрдИред рдлреЙрд▓рдмреИрдХ рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд┐рдпрд╛ рдЬрд╛ рд░рд╣рд╛ рд╣реИред', 'warning');
                    displayFallbackShareOptions(dataToShare, true);
                }
            }
        } else {
            displayFallbackShareOptions(dataToShare, true);
        }
    }

    function displayFallbackShareOptions(data, isBulkShare = false) { const existingModal = document.querySelector('.fallback-share-modal'); if (existingModal) existingModal.remove(); const cont = document.createElement('div'); cont.className = 'fallback-share-modal'; let modalContent = `<button class="settings-close-btn" style="float:right; padding:0; line-height:1;" onclick="this.parentElement.remove()">├Ч</button><h4>рд╢реЗрдпрд░ рдХрд░реЗрдВ</h4><textarea id="fallback-share-text" readonly>${data.text}</textarea><div style="margin-top: 10px;"><button class="tool-btn" style="margin-top:0; background-color:var(--success-color);" onclick="copyFallbackText()">рдЯреЗрдХреНрд╕реНрдЯ рдХреЙрдкреА рдХрд░реЗрдВ</button>`; if (!isBulkShare && data.url) { modalContent += `<a href="mailto:?subject=${encodeURIComponent(data.title)}&body=${encodeURIComponent(data.url)}" class="tool-btn-secondary" style="margin-top:0;">рдИрдореЗрд▓</a><a href="https://wa.me/?text=${encodeURIComponent(data.title + '\n' + data.url)}" data-action="share/whatsapp/share" target="_blank" class="tool-btn-secondary" style="margin-top:0;">рд╡реНрд╣рд╛рдЯреНрд╕рдПрдк</a>`; } modalContent += `</div>`; cont.innerHTML = modalContent; document.body.appendChild(cont); }
    function copyFallbackText() { const textArea = document.getElementById('fallback-share-text'); if (textArea) { textArea.select(); textArea.setSelectionRange(0, 999999); try { const successful = document.execCommand('copy'); if (successful) showToast('рдЯреЗрдХреНрд╕реНрдЯ рдХреНрд▓рд┐рдкрдмреЛрд░реНрдб рдкрд░ рдХреЙрдкреА рд╣реБрдЖ!', 'success'); else showToast('рдХреЙрдкреА рдХрд░рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ред', 'error'); } catch (err) { showToast('рдХреЙрдкреА рдХрд░рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ред', 'error'); } } }
    async function updateLibraryCount() { const count = await db.articles.count(); document.getElementById('library-count').textContent = `(${count})`; }
    
    async function getBookmarks() { return db.bookmarks.toArray(); }
    async function saveBookmarks(bookmarks) { await db.bookmarks.clear(); await db.bookmarks.bulkAdd(bookmarks); await updateBookmarkCount(); await loadBookmarks(); await populateBookmarkFolderSelectors(); }
    async function addBookmark() { const nameInput = document.getElementById('bookmarkName'); const urlInput = document.getElementById('bookmarkUrl'); const folderSelect = document.getElementById('bookmarkAssignFolder'); const name = nameInput.value.trim(); const url = urlInput.value.trim(); const folder = folderSelect.value; if (!url) { showToast('рдХреГрдкрдпрд╛ URL рдбрд╛рд▓реЗрдВ', 'error'); return; } await db.bookmarks.add({ name: name || url, url: url, addedAt: new Date().toISOString(), folder: folder }); nameInput.value = ''; urlInput.value = ''; showToast('рдмреБрдХрдорд╛рд░реНрдХ рдЬреЛрдбрд╝рд╛ рдЧрдпрд╛!', 'success'); await loadBookmarks(); }
    async function loadBookmarks() { const folderFilter = document.getElementById('bookmarkFolderFilter').value; let query = folderFilter ? db.bookmarks.where('folder').equals(folderFilter) : db.bookmarks; const bookmarks = await query.sortBy('addedAt'); const list = document.getElementById('bookmark-list'); list.innerHTML = ''; if (bookmarks.length === 0) { list.innerHTML = '<p>рдХреЛрдИ рдмреБрдХрдорд╛рд░реНрдХ рдирд╣реАрдВ рдорд┐рд▓рд╛ред</p>'; } else { bookmarks.reverse().forEach(bm => { const div = document.createElement('div'); div.className = 'bookmark-item'; div.innerHTML = `<span class="item-title" title="${bm.url}">${bm.name}</span><button class="delete-btn">рд╣рдЯрд╛рдПрдБ</button>`; div.querySelector('.item-title').onclick = () => { document.getElementById('articleUrl').value = bm.url; openTool(null, 'ArticleExtractor'); ae_startExtraction(); }; div.querySelector('.delete-btn').onclick = async () => { await db.bookmarks.delete(bm.id); await loadBookmarks(); }; list.appendChild(div); }); } await updateBookmarkCount(); }
    async function getBookmarkFolders() { const bookmarks = await db.bookmarks.toArray(); const folders = new Set(['Default']); bookmarks.forEach(bm => { if(bm.folder) folders.add(bm.folder) }); return Array.from(folders).sort((a,b) => a.localeCompare(b,'hi')); }
    async function populateBookmarkFolderSelectors() { const folders = await getBookmarkFolders(); const filterSelect = document.getElementById('bookmarkFolderFilter'); const assignSelect = document.getElementById('bookmarkAssignFolder'); const currentFilter = filterSelect.value; const currentAssign = assignSelect.value; filterSelect.innerHTML = '<option value="">рд╕рднреА рдлрд╝реЛрд▓реНрдбрд░</option>'; assignSelect.innerHTML = ''; folders.forEach(folder => { filterSelect.innerHTML += `<option value="${folder}">${folder}</option>`; assignSelect.innerHTML += `<option value="${folder}">${folder}</option>`; }); filterSelect.value = currentFilter; assignSelect.value = currentAssign || 'Default'; }
    async function createBookmarkFolder() { const nameInput = document.getElementById('newBookmarkFolderName'); const newFolder = nameInput.value.trim(); if (newFolder) { const folders = await getBookmarkFolders(); if (!folders.includes(newFolder)) { const filterSelect = document.getElementById('bookmarkFolderFilter'); const assignSelect = document.getElementById('bookmarkAssignFolder'); filterSelect.innerHTML += `<option value="${newFolder}">${newFolder}</option>`; assignSelect.innerHTML += `<option value="${newFolder}">${newFolder}</option>`; showToast(`рдлрд╝реЛрд▓реНрдбрд░ '${newFolder}' рдмрдирд╛рдпрд╛ рдЧрдпрд╛!`, 'success'); nameInput.value = ''; } else { showToast('рдпрд╣ рдлрд╝реЛрд▓реНрдбрд░ рдкрд╣рд▓реЗ рд╕реЗ рдореМрдЬреВрдж рд╣реИред', 'warning'); } } }
    async function updateBookmarkCount() { const count = await db.bookmarks.count(); document.getElementById('bookmark-count').textContent = `(${count})`; }

    async function adjustFontSizeSetting(area, delta) {
        let targetElementId, storageKey, displayElementId;
        if (area === 'extractor') { targetElementId = 'ae_result'; storageKey = 'fontSize'; displayElementId = 'extractorFontSizeDisplay';}
        else if (area === 'library') { targetElementId = 'lib-article-text-content'; storageKey = 'libraryFontSize'; displayElementId = 'libraryFontSizeDisplay';}
        else { return; }
        const targetElement = document.getElementById(targetElementId); const displayElement = document.getElementById(displayElementId);
        if (!targetElement || !displayElement) return;
        let currentSize = parseFloat(window.getComputedStyle(targetElement).fontSize);
        if (isNaN(currentSize)) currentSize = 16;
        let newSize = Math.max(10, Math.min(30, currentSize + delta));
        targetElement.style.fontSize = `${newSize}px`; await dbprefs.set(storageKey, `${newSize}px`); displayElement.textContent = `${newSize}px`;
    }
    async function applySavedFontSize() { const size = await dbprefs.get('fontSize', '16px'); if (document.getElementById('ae_result')) document.getElementById('ae_result').style.fontSize = size; if(document.getElementById('extractorFontSizeDisplay')) document.getElementById('extractorFontSizeDisplay').textContent = size; }
    async function applySavedLibraryFontSize() { const size = await dbprefs.get('libraryFontSize', '16px'); if (document.getElementById('lib-article-text-content')) document.getElementById('lib-article-text-content').style.fontSize = size; if(document.getElementById('libraryFontSizeDisplay')) document.getElementById('libraryFontSizeDisplay').textContent = size;}

    async function setDisplayMode(m) { currentDisplayMode = m; await dbprefs.set('displayMode', m); showToast(`рдбрд┐рд╕реНрдкреНрд▓реЗ рдореЛрдб рдмрджрд▓рд╛ рдЧрдпрд╛ред рдХрдВрдЯреЗрдВрдЯ рдХреЛ рдлрд┐рд░ рд╕реЗ рдирд┐рдХрд╛рд▓рдиреЗ рдкрд░ рд▓рд╛рдЧреВ рд╣реЛрдЧрд╛ред`, 'info');}
    async function applySavedDisplayMode() { const m = await dbprefs.get('displayMode', 'image-text'); currentDisplayMode = m; document.getElementById('displayModeSetting').value = m;}
    function showToast(msg, type='info', dur=3000, actions=null) { const cont = document.getElementById('toast-container'); const t = document.createElement('div'); t.className = `toast-notification ${type}`; t.textContent = msg; if (actions) { const actionsDiv = document.createElement('div'); actionsDiv.className = 'toast-actions'; actions.forEach(action => { const btn = document.createElement('button'); btn.textContent = action.text; btn.onclick = () => { action.callback(); t.remove(); }; actionsDiv.appendChild(btn); }); t.appendChild(actionsDiv); } cont.appendChild(t); setTimeout(() => t.classList.add('show'), 100); setTimeout(() => { t.classList.remove('show'); setTimeout(() => t.remove(), 500); }, dur); }
    function scrollToTop() { window.scrollTo({top: 0, behavior: 'smooth'}); }
    window.onscroll = function() { const btn = document.getElementById("backToTopBtn"); if (document.body.scrollTop > 100 || document.documentElement.scrollTop > 100) { btn.style.display = "block"; } else { btn.style.display = "none"; } };
    function addToHistory(url) { if (currentHistoryIndex < navigationHistory.length - 1) navigationHistory = navigationHistory.slice(0, currentHistoryIndex + 1); if (navigationHistory.at(-1) !== url) { navigationHistory.push(url); currentHistoryIndex = navigationHistory.length - 1; } updateHistoryButtons(); }
    function updateHistoryButtons() { const backBtn = document.getElementById('historyBackBtn'); const fwdBtn = document.getElementById('historyForwardBtn'); const cont = document.getElementById('internalNavHistoryContainer'); cont.style.display = document.getElementById('ArticleExtractor').style.display === 'block' && navigationHistory.length > 1 ? 'flex' : 'none'; backBtn.disabled = currentHistoryIndex <= 0; fwdBtn.disabled = currentHistoryIndex >= navigationHistory.length - 1; }
    function navigateHistory(dir) { if (isNavigatingHistory) return; isNavigatingHistory = true; const newIndex = currentHistoryIndex + dir; if (newIndex >= 0 && newIndex < navigationHistory.length) { currentHistoryIndex = newIndex; document.getElementById('articleUrl').value = navigationHistory[newIndex]; ae_startExtraction(true).finally(() => isNavigatingHistory = false); } else { isNavigatingHistory = false; } }
    
    async function updateTTSControlVisibility() { const method = await dbprefs.get('ttsMethod', 'stream'); const showVoiceSelector = method === 'local' && speechApiSupported; document.getElementById('libVoiceSelectorContainer').style.display = showVoiceSelector ? 'flex' : 'none'; document.getElementById('voiceSelectorContainerSetting').style.display = showVoiceSelector ? 'flex' : 'none'; }
    async function setTTSMethod(method) { await dbprefs.set('ttsMethod', method); await stopTTS(); await updateTTSControlVisibility(); showToast(`рдСрдбрд┐рдпреЛ рд╕реНрд░реЛрдд рдЕрдм ${method === 'stream' ? 'Google рд╕реНрдЯреНрд░реАрдо' : 'рдбрд┐рд╡рд╛рдЗрд╕ TTS'} рд╣реИред`, 'success'); }
    async function setTTSRate(rate) { const rateValue = parseFloat(rate).toFixed(1); await dbprefs.set('ttsRate', rateValue); const method = await dbprefs.get('ttsMethod', 'stream'); if (isPlaying && method === 'local' && speechApiSupported && localSpeechSynth && localSpeechSynth.speaking) { await stopTTS(); showToast("рдирдИ рдЧрддрд┐ рд▓рд╛рдЧреВ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдСрдбрд┐рдпреЛ рдХреЛ рдлрд┐рд░ рд╕реЗ рд╢реБрд░реВ рдХрд░реЗрдВред", "info"); } if (currentAudioElement) { currentAudioElement.playbackRate = rateValue; } document.getElementById('ttsRateDisplaySetting').textContent = `${rateValue}x`; }
    async function setTTSVoice(voiceURI) { await dbprefs.set('ttsVoice', voiceURI); document.getElementById('libVoiceSelector').value = voiceURI; document.getElementById('voiceSelectorSetting').value = voiceURI; const method = await dbprefs.get('ttsMethod', 'stream'); if(isPlaying && method === 'local') { await stopTTS(); showToast("рдирдИ рдЖрд╡рд╛рдЬрд╝ рд▓рд╛рдЧреВ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдСрдбрд┐рдпреЛ рдХреЛ рдлрд┐рд░ рд╕реЗ рд╢реБрд░реВ рдХрд░реЗрдВред", "info");} }
    async function populateVoiceSelector() { if (!speechApiSupported || !localSpeechSynth) return; const voices = localSpeechSynth.getVoices(); if (voices.length === 0) { console.warn("getVoices() returned an empty array. Retrying in 1s."); setTimeout(populateVoiceSelector, 1000); return; } const libVoiceSelector = document.getElementById('libVoiceSelector'); const settingsVoiceSelector = document.getElementById('voiceSelectorSetting'); const currentLibVoice = libVoiceSelector.value; const currentSettingsVoice = settingsVoiceSelector.value; libVoiceSelector.innerHTML = ''; settingsVoiceSelector.innerHTML = ''; const hindiVoices = voices.filter(v => v.lang.toLowerCase().startsWith('hi')); const otherVoices = voices.filter(v => !v.lang.toLowerCase().startsWith('hi')); const createOption = (voice) => `<option value="${voice.voiceURI}">${voice.name} (${voice.lang})</option>`; let optionsHTML = ''; if (hindiVoices.length > 0) { optionsHTML += `<optgroup label="рд╣рд┐рдиреНрджреА">` + hindiVoices.map(createOption).join('') + `</optgroup>`; } if (otherVoices.length > 0) { optionsHTML += `<optgroup label="рдЕрдиреНрдп рднрд╛рд╖рд╛рдПрдВ">` + otherVoices.map(createOption).join('') + `</optgroup>`; } libVoiceSelector.innerHTML = optionsHTML; settingsVoiceSelector.innerHTML = optionsHTML; const savedVoice = await dbprefs.get('ttsVoice'); if (savedVoice && voices.find(v => v.voiceURI === savedVoice)) { libVoiceSelector.value = savedVoice; settingsVoiceSelector.value = savedVoice; } else if (hindiVoices.length > 0) { libVoiceSelector.value = hindiVoices[0].voiceURI; settingsVoiceSelector.value = hindiVoices[0].voiceURI; await dbprefs.set('ttsVoice', hindiVoices[0].voiceURI); } else if (currentLibVoice && voices.find(v => v.voiceURI === currentLibVoice)) { libVoiceSelector.value = currentLibVoice; } else if (currentSettingsVoice && voices.find(v => v.voiceURI === currentSettingsVoice)) { settingsVoiceSelector.value = currentSettingsVoice; } else if (voices.length > 0) { libVoiceSelector.value = voices[0].voiceURI; settingsVoiceSelector.value = voices[0].voiceURI; await dbprefs.set('ttsVoice', voices[0].voiceURI); } updateTTSControlVisibility(); }
    async function applySavedTTSSettings() { const savedRate = await dbprefs.get('ttsRate', '1.0'); document.getElementById('ttsRateSetting').value = savedRate; await setTTSRate(savedRate); const savedMethod = await dbprefs.get('ttsMethod', 'stream'); document.getElementById('ttsMethodSetting').value = savedMethod; await updateTTSControlVisibility(); }
    function setSleepTimer(minutes) { cancelSleepTimer(); if (minutes == 0) return; if (minutes == -1) { stopAtArticleEnd = true; document.getElementById('sleepTimerDisplay').textContent = "рдЖрд░реНрдЯрд┐рдХрд▓ рдХреЗ рдЕрдВрдд рдореЗрдВ рд░реБрдХреЗрдЧрд╛ред"; document.getElementById('cancelSleepTimerBtn').style.display = 'inline-block'; showToast("рд╕реНрд▓реАрдк рдЯрд╛рдЗрдорд░ рд╕реЗрдЯ: рдЖрд░реНрдЯрд┐рдХрд▓ рдХреЗ рдЕрдВрдд рдореЗрдВ рд░реБрдХреЗрдЧрд╛ред", "success"); } else { const durationInMs = parseInt(minutes, 10) * 60 * 1000; sleepTimerEndTime = Date.now() + durationInMs; sleepTimerId = setTimeout(async () => { showToast("рд╕реНрд▓реАрдк рдЯрд╛рдЗрдорд░ рд╕рдорд╛рдкреНрддред рдСрдбрд┐рдпреЛ рд░реЛрдХрд╛ рдЬрд╛ рд░рд╣рд╛ рд╣реИред", "info"); await stopTTS(); cancelSleepTimer(); }, durationInMs); sleepTimerIntervalId = setInterval(updateSleepTimerDisplay, 1000); updateSleepTimerDisplay(); document.getElementById('cancelSleepTimerBtn').style.display = 'inline-block'; showToast(`${minutes} рдорд┐рдирдЯ рдХрд╛ рд╕реНрд▓реАрдк рдЯрд╛рдЗрдорд░ рд╕реЗрдЯ рдХрд┐рдпрд╛ рдЧрдпрд╛ред`, "success"); } }
    function updateSleepTimerDisplay() { const remainingTime = sleepTimerEndTime - Date.now(); if (remainingTime <= 0) { cancelSleepTimer(); return; } const minutes = Math.floor(remainingTime / 60000); const seconds = Math.floor((remainingTime % 60000) / 1000).toString().padStart(2, '0'); document.getElementById('sleepTimerDisplay').textContent = `рдмрд╛рдХреА рд╕рдордп: ${minutes}:${seconds}`; }
    function cancelSleepTimer() { if (sleepTimerId) { clearTimeout(sleepTimerId); sleepTimerId = null; } if (sleepTimerIntervalId) { clearInterval(sleepTimerIntervalId); sleepTimerIntervalId = null; } stopAtArticleEnd = false; const timerDisplay = document.getElementById('sleepTimerDisplay'); if (timerDisplay) { timerDisplay.textContent = ""; document.getElementById('sleepTimerSelect').value = "0"; document.getElementById('cancelSleepTimerBtn').style.display = 'none'; } }
    function updatePlaylistControls() {
        const selectedCount = document.querySelectorAll('.playlist-checkbox:checked').length;
        const show = selectedCount > 0;
        document.getElementById('playSelectedBtn').style.display = show ? 'inline-block' : 'none';
        document.getElementById('createSelectedMp3Btn').style.display = show ? 'inline-block' : 'none';
        document.getElementById('libraryBatchControls').style.display = show ? 'flex' : 'none';
        
        const totalCount = document.querySelectorAll('.playlist-checkbox').length;
        const selectAllCheckbox = document.getElementById('selectAllCheckbox');
        if(selectAllCheckbox) {
            selectAllCheckbox.checked = selectedCount > 0 && selectedCount === totalCount;
            selectAllCheckbox.indeterminate = selectedCount > 0 && selectedCount < totalCount;
        }
    }
    async function playSelectedLibraryItems() { const selectedUrls = Array.from(document.querySelectorAll('.playlist-checkbox:checked')).map(cb => cb.dataset.url); if (selectedUrls.length > 0) { await clearQueue(); const articles = await db.articles.bulkGet(selectedUrls); for (const article of articles) { if(article) await addToQueue(article); } startQueuePlayback(); } }
    async function createSelectedMp3() { const checkboxes = document.querySelectorAll('.playlist-checkbox:checked'); if (checkboxes.length === 0) return; const btn = document.getElementById('createSelectedMp3Btn'); const urls = Array.from(checkboxes).map(cb => cb.dataset.url); const articles = await db.articles.bulkGet(urls); let text = ''; articles.forEach(articleData => { if (articleData) text += `${articleData.title}.\n${articleData.textContent}\n\n`; }); await downloadTextAsMp3(text, 'playlist', btn); }
    async function playNextInQueueOrAutoplay(fromRemoval = false) {
        let nextIndexToPlay = -1;

        if (!fromRemoval && currentQueueIndex < playQueue.length - 1) {
            nextIndexToPlay = currentQueueIndex + 1;
        } else if (fromRemoval && currentQueueIndex < playQueue.length) {
            nextIndexToPlay = currentQueueIndex;
        } else if (audioPlayerState.repeatMode === 'all' && playQueue.length > 0) {
            nextIndexToPlay = 0;
        }

        if (nextIndexToPlay !== -1 && nextIndexToPlay < playQueue.length) {
            await playQueueItem(nextIndexToPlay);
            return true;
        }

        const isAutoplayOn = await dbprefs.get('autoplay', false);
        if (isAutoplayOn && audioPlayerState.currentArticle) {
            const currentUrl = audioPlayerState.currentArticle.url;
            const allItemElements = Array.from(document.querySelectorAll('#library-list .library-item'));
            const currentIndexInDom = allItemElements.findIndex(el => {
                const checkbox = el.querySelector('.playlist-checkbox');
                return checkbox && checkbox.dataset.url === currentUrl;
            });

            if (currentIndexInDom > -1 && currentIndexInDom < allItemElements.length - 1) {
                const nextItemEl = allItemElements[currentIndexInDom + 1];
                const nextUrl = nextItemEl.querySelector('.playlist-checkbox')?.dataset.url;
                if (nextUrl) {
                    const nextArticleData = await db.articles.get(nextUrl);
                    if (nextArticleData) {
                        await clearQueue();
                        await addToQueue(nextArticleData);
                        return true;
                    }
                }
            }
        }

        if (isPlaying || isPaused) {
             showToast("рдкреНрд▓реЗрдмреИрдХ рдХреНрдпреВ рд╕рдорд╛рдкреНрддред", "info");
        }
        await stopTTS();
        hideAudioPlayer();
        currentQueueIndex = -1;
        audioPlayerState.currentArticle = null;
        updateQueueDisplay();
        await saveQueue();
        return false;
    }
    async function handleAutoPlayToggle(isChecked) { await dbprefs.set('autoplay', isChecked); }
    function updateMediaSession(article, state = 'playing') { if (!mediaSessionSupported) return; if (!article || !article.title) { navigator.mediaSession.metadata = null; navigator.mediaSession.playbackState = 'none'; return; } navigator.mediaSession.metadata = new MediaMetadata({ title: article.title, artist: article.byline || window.location.hostname, album: 'рдЖрд░реНрдЯрд┐рдХрд▓ рд░реАрдбрд░ рдкреНрд░реЛ', artwork: [{ src: 'https://cdn-icons-png.flaticon.com/512/864/864348.png', sizes: '512x512', type: 'image/png' }] }); navigator.mediaSession.playbackState = state; }
    const settingsModal = document.getElementById('settingsModal');
    async function openSettingsModal() { await loadSettingsIntoModal(); settingsModal.style.pointerEvents = 'auto'; settingsModal.classList.add('show'); window.addEventListener('keydown', handleSettingsEscKey); }
    function closeSettingsModal() { settingsModal.classList.remove('show'); setTimeout(() => { settingsModal.style.pointerEvents = 'none'; }, 300); window.removeEventListener('keydown', handleSettingsEscKey); }
    function handleSettingsEscKey(e) { if (e.key === 'Escape') { closeSettingsModal(); } }
    settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) { closeSettingsModal(); } });
    async function loadSettingsIntoModal() {
        const currentTheme = await dbprefs.get('theme', 'light');
        const themeRadio = document.querySelector(`input[name="theme_setting"][value="${currentTheme}"]`);
        if(themeRadio) themeRadio.checked = true;
        else document.querySelector(`input[name="theme_setting"][value="light"]`).checked = true;

        await applySavedDisplayMode();
        await applySavedTTSSettings();
        await applySavedFontSize();
        await applySavedLibraryFontSize();
        const autoRefreshValue = await dbprefs.get('rssAutoRefresh', '0');
        document.getElementById('rssAutoRefreshSetting').value = autoRefreshValue;
        await renderRulesList();
    }
    document.querySelectorAll('input[name="theme_setting"]').forEach(radio => { radio.addEventListener('change', (e) => toggleTheme(e.target.value)); });
    document.getElementById('displayModeSetting').addEventListener('change', (e) => { setDisplayMode(e.target.value); });
    document.getElementById('ttsMethodSetting').addEventListener('change', (e) => { setTTSMethod(e.target.value); loadSettingsIntoModal(); });
    document.getElementById('ttsRateSetting').addEventListener('input', (e) => { setTTSRate(e.target.value); });
    document.getElementById('voiceSelectorSetting').addEventListener('change', (e) => { setTTSVoice(e.target.value); });
    async function exportLibrary() { const library = await db.articles.toArray(); if (library.length === 0) { showToast("рд▓рд╛рдЗрдмреНрд░реЗрд░реА рдЦрд╛рд▓реА рд╣реИ, рдПрдХреНрд╕рдкреЛрд░реНрдЯ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдХреБрдЫ рдирд╣реАрдВ рд╣реИред", "warning"); return; } const dataStr = JSON.stringify(library, null, 2); const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr); const exportFileDefaultName = 'article_reader_library_export.json'; const linkElement = document.createElement('a'); linkElement.setAttribute('href', dataUri); linkElement.setAttribute('download', exportFileDefaultName); linkElement.click(); showToast("рд▓рд╛рдЗрдмреНрд░реЗрд░реА рдПрдХреНрд╕рдкреЛрд░реНрдЯ рдХреА рдЧрдИ!", "success"); }
    function importLibraryHandler(event) { const file = event.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = async (e) => { try { const importedLibrary = JSON.parse(e.target.result); if (Array.isArray(importedLibrary)) { await db.articles.bulkPut(importedLibrary); showToast("рд▓рд╛рдЗрдмреНрд░реЗрд░реА рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдЗрдВрдкреЛрд░реНрдЯ рдХреА рдЧрдИ!", "success"); await loadLibrary(); await updateLibraryCount(); } else { throw new Error("рдЕрдорд╛рдиреНрдп JSON рд╕рдВрд░рдЪрдирд╛ (рдПрдХ рдРрд░реЗ рдХреА рдЙрдореНрдореАрдж рдереА)ред"); } } catch (err) { showToast("рд▓рд╛рдЗрдмреНрд░реЗрд░реА рдЗрдВрдкреЛрд░реНрдЯ рдХрд░рдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐: " + err.message, "error"); } }; reader.readAsText(file); event.target.value = null; } }
    async function clearLibraryData() { if (confirm('рдХреНрдпрд╛ рдЖрдк рд╡рд╛рдХрдИ рдЕрдкрдиреА рдкреВрд░реА рд▓рд╛рдЗрдмреНрд░реЗрд░реА рдФрд░ рдХрд▓реЗрдХреНрд╢рди рд╣рдЯрд╛рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ? рдпрд╣ рдХреНрд░рд┐рдпрд╛ рд╡рд╛рдкрд╕ рдирд╣реАрдВ рдХреА рдЬрд╛ рд╕рдХрддреАред')) { await db.articles.clear(); await db.collections.clear(); await dbprefs.remove('playbackPositions'); await db.runtime_state.clear(); await dbprefs.remove('scrollPositions'); await loadLibrary(); await updateLibraryCount(); await initCollections(); const view = document.getElementById('library-article-view'); if (view) view.style.display = 'none'; audioPlayerState.currentArticle = null; await stopTTS(); showToast('рд▓рд╛рдЗрдмреНрд░реЗрд░реА рд╕рд╛рдлрд╝ рдХрд░ рджреА рдЧрдИ рд╣реИред', 'success'); } }
    async function clearBookmarksData() { if (confirm('рдХреНрдпрд╛ рдЖрдк рд╡рд╛рдХрдИ рдЕрдкрдиреЗ рд╕рднреА рдмреБрдХрдорд╛рд░реНрдХ рд╣рдЯрд╛рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ? рдпрд╣ рдХреНрд░рд┐рдпрд╛ рд╡рд╛рдкрд╕ рдирд╣реАрдВ рдХреА рдЬрд╛ рд╕рдХрддреАред')) { await db.bookmarks.clear(); await loadBookmarks(); await updateBookmarkCount(); showToast('рд╕рднреА рдмреБрдХрдорд╛рд░реНрдХ рд╣рдЯрд╛ рджрд┐рдП рдЧрдП рд╣реИрдВред', 'success'); } }
    async function resetAllSettings() { if (confirm('рдХреНрдпрд╛ рдЖрдк рд╡рд╛рдХрдИ рд╕рднреА рд╕реЗрдЯрд┐рдВрдЧреНрд╕ рдФрд░ рдбреЗрдЯрд╛ рдХреЛ рдбрд┐рдлрд╝реЙрд▓реНрдЯ рдкрд░ рд░реАрд╕реЗрдЯ рдХрд░рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ? рдЖрдкрдХреА рд▓рд╛рдЗрдмреНрд░реЗрд░реА рдФрд░ рдмреБрдХрдорд╛рд░реНрдХ рд╕рд╣рд┐рдд рд╕рдм рдХреБрдЫ рд╣рдЯрд╛ рджрд┐рдпрд╛ рдЬрд╛рдПрдЧрд╛ред')) { await Dexie.delete('ArticleReaderProDB'); showToast('рд╕рднреА рд╕реЗрдЯрд┐рдВрдЧреНрд╕ рд░реАрд╕реЗрдЯ рдХрд░ рджреА рдЧрдИ рд╣реИрдВред рдкреЗрдЬ рд░реАрд▓реЛрдб рд╣реЛ рд░рд╣рд╛ рд╣реИ...', 'success', 3000); setTimeout(() => location.reload(), 3000); } }
    function performGoogleSearch() { const query = document.getElementById('googleSearchQuery').value; if (query.trim()) { const searchUrl = `https://www.google.com/search?q=${encodeURIComponent(query)}`; window.open(searchUrl, '_blank'); } }

    // --- Library Batch Operations ---
    function toggleSelectAll(checked) {
        document.querySelectorAll('#library-list .playlist-checkbox').forEach(cb => {
            cb.checked = checked;
        });
        updatePlaylistControls();
    }
    
    function getSelectedArticleUrls() {
        return Array.from(document.querySelectorAll('#library-list .playlist-checkbox:checked')).map(cb => cb.dataset.url);
    }

    async function handleBatchDelete() {
        const selectedUrls = getSelectedArticleUrls();
        if (selectedUrls.length === 0) {
            showToast("рдХреЛрдИ рдЖрд░реНрдЯрд┐рдХрд▓ рдирд╣реАрдВ рдЪреБрдирд╛ рдЧрдпрд╛ред", "warning");
            return;
        }
        if (confirm(`рдХреНрдпрд╛ рдЖрдк рд╡рд╛рдХрдИ ${selectedUrls.length} рдЖрд░реНрдЯрд┐рдХрд▓ рд╣рдЯрд╛рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ?`)) {
            await db.articles.bulkDelete(selectedUrls);
            await loadLibrary();
            await updateLibraryCount();
            showToast(`${selectedUrls.length} рдЖрд░реНрдЯрд┐рдХрд▓ рд╣рдЯрд╛ рджрд┐рдП рдЧрдПред`, 'success');
        }
    }

    async function handleBatchTag() {
        const selectedUrls = getSelectedArticleUrls();
        if (selectedUrls.length === 0) {
            showToast("рдХреЛрдИ рдЖрд░реНрдЯрд┐рдХрд▓ рдирд╣реАрдВ рдЪреБрдирд╛ рдЧрдпрд╛ред", "warning");
            return;
        }
        const tagName = prompt(`рдЗрди ${selectedUrls.length} рдЖрд░реНрдЯрд┐рдХрд▓реНрд╕ рдореЗрдВ рдХреМрди рд╕рд╛ рдЯреИрдЧ рдЬреЛрдбрд╝рдирд╛ рд╣реИ?`);
        if (tagName && tagName.trim()) {
            const cleanTagName = tagName.trim().toLowerCase();
            const articlesToUpdate = await db.articles.bulkGet(selectedUrls);
            articlesToUpdate.forEach(article => {
                if(article) {
                    const newTags = new Set(article.tags || []);
                    newTags.add(cleanTagName);
                    article.tags = Array.from(newTags);
                }
            });
            await db.articles.bulkPut(articlesToUpdate.filter(Boolean));
            await populateTagFilter();
            showToast(`рдЯреИрдЧ '${cleanTagName}' ${selectedUrls.length} рдЖрд░реНрдЯрд┐рдХрд▓реНрд╕ рдореЗрдВ рдЬреЛрдбрд╝рд╛ рдЧрдпрд╛ред`, 'success');
        }
    }

    async function handleBatchMarkAsRead(isRead) {
        const selectedUrls = getSelectedArticleUrls();
        if (selectedUrls.length === 0) {
            showToast("рдХреЛрдИ рдЖрд░реНрдЯрд┐рдХрд▓ рдирд╣реАрдВ рдЪреБрдирд╛ рдЧрдпрд╛ред", "warning");
            return;
        }
        await db.articles.where('url').anyOf(selectedUrls).modify({ isRead: isRead });
        await loadLibrary();
        showToast(`${selectedUrls.length} рдЖрд░реНрдЯрд┐рдХрд▓ рдХреЛ '${isRead ? 'рдкрдврд╝рд╛ рд╣реБрдЖ' : 'рдЕрдкрдард┐рдд'}' рдЪрд┐рд╣реНрдирд┐рдд рдХрд┐рдпрд╛ рдЧрдпрд╛ред`, 'success');
    }


    // --- RSS Feed Functions ---
    async function getRssReadItems() { return await dbprefs.get('rssReadItems', {}); }
    async function saveRssReadItems(readItems) { await dbprefs.set('rssReadItems', readItems);}
    async function isRssArticleRead(feedUrl, articleLink) { const readItems = await getRssReadItems(); return readItems[feedUrl] && readItems[feedUrl].includes(articleLink); }
    async function markRssArticleAsRead(feedUrl, articleLink) { const readItems = await getRssReadItems(); if (!readItems[feedUrl]) { readItems[feedUrl] = []; } if (!readItems[feedUrl].includes(articleLink)) { readItems[feedUrl].push(articleLink); await saveRssReadItems(readItems); await displaySubscribedFeeds(); } }
    async function markRssArticleAsUnread(feedUrl, articleLink) { const readItems = await getRssReadItems(); if (readItems[feedUrl] && readItems[feedUrl].includes(articleLink)) { readItems[feedUrl] = readItems[feedUrl].filter(link => link !== articleLink); if (readItems[feedUrl].length === 0) { delete readItems[feedUrl]; } await saveRssReadItems(readItems); await displaySubscribedFeeds(); } }
    async function markAllRssFeedArticles(feedUrl, feedItems, asRead = true) { const readItems = await getRssReadItems(); if (asRead) { if (!readItems[feedUrl]) { readItems[feedUrl] = []; } feedItems.forEach(item => { if (item && item.link && !readItems[feedUrl].includes(item.link)) { readItems[feedUrl].push(item.link); } }); } else { showToast("рдпрд╣ рд╕реБрд╡рд┐рдзрд╛ рдЕрднреА рд▓рд╛рдЧреВ рдирд╣реАрдВ рд╣реИред", "warning"); return; } await saveRssReadItems(readItems); const feeds = await getSubscribedFeeds(); const currentFeed = feeds.find(f => f.url === feedUrl); if (currentFeed && document.getElementById('rssFeedTitleDisplay').textContent.includes(currentFeed.title || currentFeed.url) ) { await displayRssFeedArticles(currentFeed); } await displaySubscribedFeeds(); showToast(`рдлрд╝реАрдб рдХреЗ рд╕рднреА рд▓реЗрдЦ "${currentFeed ? (currentFeed.title || currentFeed.url).substring(0,20)+'...' : ''}" рдкрдврд╝реЗ рд╣реБрдП рдЪрд┐рд╣реНрдирд┐рддред`, "success");}

    async function getSubscribedFeeds() { return await db.rss_feeds.toArray(); }
    async function saveSubscribedFeeds(feeds) { await db.rss_feeds.bulkPut(feeds); await displaySubscribedFeeds(); await updateRssFeedCount(); }
    async function updateRssFeedCount() { const count = await db.rss_feeds.count(); document.getElementById('rss-feed-count').textContent = `(${count})`;}
    async function addRssFeed(feedUrl, feedTitle, suppressToast = false) {
        let urlToAdd = feedUrl;
        if (!urlToAdd) {
            const urlInputEl = document.getElementById('rssFeedUrlInput');
            urlToAdd = urlInputEl.value.trim();
            if (!urlToAdd) { showToast("рдХреГрдкрдпрд╛ URL рдбрд╛рд▓реЗрдВред", "error"); return; }
        }
        
        if (!suppressToast) showToast("RSS рдлрд╝реАрдб рдЦреЛрдЬрд╛ рдЬрд╛ рд░рд╣рд╛ рд╣реИ...", "info");
        
        try {
            let finalFeedUrl = urlToAdd;
            if (!urlToAdd.toLowerCase().endsWith('.xml') && !urlToAdd.toLowerCase().endsWith('.rss') && !urlToAdd.toLowerCase().includes('/feed') && !urlToAdd.toLowerCase().includes('rss.xml')) {
                const foundFeedUrl = await findRssFeedUrlOnPage(urlToAdd);
                if (foundFeedUrl) {
                    finalFeedUrl = foundFeedUrl;
                    if (!suppressToast) showToast(`RSS рдлрд╝реАрдб рдорд┐рд▓рд╛: ${finalFeedUrl}`, "info");
                } else {
                    if (!suppressToast) showToast("рдЗрд╕ рдкреЗрдЬ рдкрд░ рдХреЛрдИ рд╕реНрдкрд╖реНрдЯ RSS рдлрд╝реАрдб рдирд╣реАрдВ рдорд┐рд▓рд╛ред рджрд┐рдП рдЧрдП URL рдХреЛ рдлрд╝реАрдб рдХреЗ рд░реВрдк рдореЗрдВ рдЗрд╕реНрддреЗрдорд╛рд▓ рдХрд░рдиреЗ рдХрд╛ рдкреНрд░рдпрд╛рд╕ рдХрд┐рдпрд╛ рдЬрд╛ рд░рд╣рд╛ рд╣реИред", "warning");
                }
            }
            
            const existingFeed = await db.rss_feeds.get(finalFeedUrl);
            if (existingFeed) {
                if (!suppressToast) showToast("рдпрд╣ рдлрд╝реАрдб рдкрд╣рд▓реЗ рд╕реЗ рд╕рдмреНрд╕рдХреНрд░рд╛рдЗрдм рдХрд┐рдпрд╛ рд╣реБрдЖ рд╣реИред", "warning");
                return false;
            }

            const parsedFeed = await parseRssFeed(finalFeedUrl);
            if (!parsedFeed || !parsedFeed.items || parsedFeed.items.length === 0) {
                 if (!suppressToast) showToast("RSS рдлрд╝реАрдб рдХреЛ рдкрд╛рд░реНрд╕ рдирд╣реАрдВ рдХрд┐рдпрд╛ рдЬрд╛ рд╕рдХрд╛ рдпрд╛ рдЙрд╕рдореЗрдВ рдХреЛрдИ рдЖрдЗрдЯрдо рдирд╣реАрдВ рд╣реИред", "error");
                 return false;
            }
            const newFeed = { title: feedTitle || parsedFeed.title || finalFeedUrl, url: finalFeedUrl, lastFetched: new Date().toISOString(), items: parsedFeed.items.slice(0, 30) };
            await db.rss_feeds.put(newFeed);
            
            const urlInputEl = document.getElementById('rssFeedUrlInput');
            if (urlInputEl) urlInputEl.value = '';
            
            if (!suppressToast) {
                showToast(`рдлрд╝реАрдб "${parsedFeed.title || finalFeedUrl}" рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдЬреЛрдбрд╝рд╛ рдЧрдпрд╛!`, "success");
                await displayRssFeedArticles(newFeed);
            }
            await displaySubscribedFeeds();
            await updateRssFeedCount();
            return true;
        } catch (error) {
            console.error("рдлрд╝реАрдб рдЬреЛрдбрд╝рдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐:", error);
            if (!suppressToast) showToast(`рдлрд╝реАрдб рдЬреЛрдбрд╝рдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐: ${error.message}`, "error", 5000);
            return false;
        }
    }
    async function findRssFeedUrlOnPage(pageUrl) {
        try {
            const html = await fetchWithProxy(pageUrl);
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, "text/html");
            const rssLink = doc.querySelector('link[type="application/rss+xml"]');
            if (rssLink && rssLink.href) return new URL(rssLink.href, pageUrl).href;
            const atomLink = doc.querySelector('link[type="application/atom+xml"]');
            if (atomLink && atomLink.href) return new URL(atomLink.href, pageUrl).href;
            return null;
        } catch (error) { console.warn(`рдкреЗрдЬ рд╕реЗ RSS рдлрд╝реАрдб рдЦреЛрдЬрдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐ ${pageUrl}:`, error); return null; }
    }
    async function parseRssFeed(feedUrl) {
        // showToast(`рдлрд╝реАрдб ${feedUrl.substring(0,40)}... рдкрд╛рд░реНрд╕ рдХрд┐рдпрд╛ рдЬрд╛ рд░рд╣рд╛ рд╣реИ`, "info", 2000);
        const xmlText = await fetchWithProxy(feedUrl);
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlText, "application/xml");
        const errorNode = xmlDoc.querySelector("parsererror");
        if (errorNode) { console.error("XML рдкрд╛рд░реНрд╕рд┐рдВрдЧ рддреНрд░реБрдЯрд┐:", errorNode.textContent); throw new Error("рдлрд╝реАрдб XML рдХреЛ рдкрд╛рд░реНрд╕ рдирд╣реАрдВ рдХрд┐рдпрд╛ рдЬрд╛ рд╕рдХрд╛ред");}
        const feed = { title: '', items: [] };
        let channelTitleElement = xmlDoc.querySelector("feed > title");
        let itemElementsSelector = "feed > entry";
        if (!channelTitleElement) {
            channelTitleElement = xmlDoc.querySelector("channel > title");
            itemElementsSelector = "channel > item";
        }
        if (channelTitleElement) feed.title = channelTitleElement.textContent.trim();
        else { console.warn("рдлрд╝реАрдб рд╢реАрд░реНрд╖рдХ рдирд╣реАрдВ рдорд┐рд▓рд╛ for:", feedUrl); feed.title = feedUrl; }

        xmlDoc.querySelectorAll(itemElementsSelector).forEach(itemElem => {
            let title = itemElem.querySelector("title")?.textContent.trim();
            let link;
            if (itemElementsSelector === "feed > entry") {
                link = itemElem.querySelector("link[rel='alternate']")?.getAttribute('href') || itemElem.querySelector("link")?.getAttribute('href');
            } else {
                link = itemElem.querySelector("link")?.textContent.trim();
            }
            if(link && link.startsWith("//")) link = "https:" + link; // Handle protocol-relative URLs
            if (link && !link.startsWith('http') && !link.includes('://')) {
                 try { link = new URL(link, feedUrl).href; } catch(e){ console.warn("Invalid link in feed:", link); link = null;}
            }
            const pubDate = itemElem.querySelector("pubDate")?.textContent.trim() || itemElem.querySelector("published")?.textContent.trim() || itemElem.querySelector("updated")?.textContent.trim();
            let description = itemElem.querySelector("description")?.textContent.trim() || itemElem.querySelector("summary")?.textContent.trim() || itemElem.querySelector("content")?.textContent.trim();
            if (description) {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = description;
                description = tempDiv.textContent || tempDiv.innerText || "";
                description = description.substring(0, 150) + (description.length > 150 ? "..." : "");
            }
            if (title && link) feed.items.push({ title, link, pubDate, description, sourceFeedUrl: feedUrl });
        });
        if(feed.items.length === 0) console.warn("рдХреЛрдИ рдЖрдЗрдЯрдо рдкрд╛рд░реНрд╕ рдирд╣реАрдВ рд╣реБрдЖ for:", feedUrl, xmlDoc);
        return feed;
    }
    async function displaySubscribedFeeds() {
        const feeds = await getSubscribedFeeds();
        const listDiv = document.getElementById('subscribedFeedsList');
        listDiv.innerHTML = '<h4>рд╕рдмреНрд╕рдХреНрд░рд╛рдЗрдм рдХрд┐рдП рдЧрдП рдлрд╝реАрдбреНрд╕:</h4>';
        if (feeds.length === 0) {
            listDiv.innerHTML += '<p>рдЕрднреА рдХреЛрдИ рдлрд╝реАрдб рд╕рдмреНрд╕рдХреНрд░рд╛рдЗрдм рдирд╣реАрдВ рдХрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред</p>';
            document.getElementById('rssFeedTitleDisplay').textContent = '';
            document.getElementById('rssArticlesList').innerHTML = '';
            return;
        }
        const ul = document.createElement('ul');
        for (const [index, feed] of feeds.entries()) {
             if (!feed || !feed.url) { console.warn("Skipping invalid feed object in subscribed list:", feed); continue; }
            const li = document.createElement('li');
            const feedTitleText = (feed.title || feed.url).length > 60 ? (feed.title || feed.url).substring(0, 57) + '...' : (feed.title || feed.url);

            let unreadCount = 0;
            if (feed.items && Array.isArray(feed.items)) {
                 for (const item of feed.items) {
                    if (item && item.link && !(await isRssArticleRead(feed.url, item.link))) {
                        unreadCount++;
                    }
                }
            }

            let feedTitleDisplay = feedTitleText;
            if (unreadCount > 0) {
                feedTitleDisplay += ` <strong style="color:var(--success-color);">(${unreadCount})</strong>`;
            }

            li.innerHTML = `
                <a href="#" onclick="displayRssFeedArticlesByIndex(${index}); return false;" title="${feed.title || feed.url}">${feedTitleDisplay}</a>
                <div>
                    <button class="tool-btn-secondary" onclick="refreshRssFeed(${index})" title="рд░рд┐рдлреНрд░реЗрд╢" style="margin-left:5px; font-size:0.8em; padding: 3px 6px; margin-top:0;">ЁЯФД</button>
                    <button class="tool-btn-secondary danger-btn" onclick="deleteRssFeed(${index})" title="рд╣рдЯрд╛рдПрдВ" style="margin-left:5px; font-size:0.8em; padding: 3px 6px; margin-top:0;">тЬЧ</button>
                </div>`;
            ul.appendChild(li);
        }
        listDiv.appendChild(ul);
    }
    async function displayRssFeedArticlesByIndex(index) {
        const feeds = await getSubscribedFeeds();
        if(feeds[index]) await displayRssFeedArticles(feeds[index]);
    }
    async function displayRssFeedArticles(feed) {
        if (!feed || !feed.url) {
            document.getElementById('rssFeedTitleDisplay').textContent = 'рдлрд╝реАрдб рд▓реЛрдб рдХрд░рдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐ред';
            document.getElementById('rssArticlesList').innerHTML = '<p>рдХреЛрдИ рдлрд╝реАрдб рдЪрдпрдирд┐рдд рдирд╣реАрдВ рд╣реИ рдпрд╛ рдлрд╝реАрдб рдЕрдорд╛рдиреНрдп рд╣реИред</p>';
            return;
        }
        document.getElementById('rssFeedTitleDisplay').textContent = `рдЖрд░реНрдЯрд┐рдХрд▓: ${feed.title || feed.url}`;
        const articlesListDiv = document.getElementById('rssArticlesList');
        articlesListDiv.innerHTML = '';

        if (!feed.items || feed.items.length === 0) {
            articlesListDiv.innerHTML += '<p>рдЗрд╕ рдлрд╝реАрдб рдореЗрдВ рдХреЛрдИ рдЖрд░реНрдЯрд┐рдХрд▓ рдирд╣реАрдВ рд╣реИ рдпрд╛ рдЕрднреА рд▓реЛрдб рдирд╣реАрдВ рд╣реБрдП рд╣реИрдВред</p>';
            return;
        }

        const headerControlsDiv = document.createElement('div');
        headerControlsDiv.style.marginBottom = '10px';
        headerControlsDiv.style.display = 'flex';
        headerControlsDiv.style.gap = '10px';
        headerControlsDiv.innerHTML = `<button class="tool-btn-secondary" style="font-size:0.8em;padding:5px 10px;margin:0;">рд╕рднреА рдХреЛ рдкрдврд╝рд╛ рдЪрд┐рд╣реНрдирд┐рдд рдХрд░реЗрдВ</button>`;
        headerControlsDiv.firstElementChild.onclick = () => { markAllRssFeedArticles(feed.url, feed.items, true); };
        articlesListDiv.appendChild(headerControlsDiv);


        for (const item of feed.items) {
            if (!item || !item.link || !item.title) { console.warn("Skipping invalid RSS item:", item); continue; }
            const articleDiv = document.createElement('div');
            articleDiv.className = 'rss-article-item';
            const isRead = await isRssArticleRead(feed.url, item.link);

            articleDiv.style.opacity = isRead ? '0.6' : '1';
            articleDiv.style.backgroundColor = isRead ? 'var(--bg-color)' : 'transparent';
            
            let itemHtml = `<span class="item-title" title="${item.title}" style="font-weight:${isRead ? 'normal' : 'bold'};">${item.title}</span>`;
            if (item.pubDate) {
                itemHtml += `<br><small>рдкреНрд░рдХрд╛рд╢рд┐рдд: ${new Date(item.pubDate).toLocaleString()}</small>`;
            }
            itemHtml += `<button class="rss-read-toggle-btn tool-btn-secondary" style="float:right; font-size:0.7em; padding: 3px 6px; margin-left:5px; margin-top:0;">${isRead ? 'рдЕрдкрдард┐рдд рдХрд░реЗрдВ' : 'рдкрдврд╝рд╛ рдХрд░реЗрдВ'}</button>`;
            articleDiv.innerHTML = itemHtml;

            const titleSpan = articleDiv.querySelector('.item-title');
            if (titleSpan) {
                titleSpan.onclick = async () => {
                    await markRssArticleAsRead(feed.url, item.link);
                    document.getElementById('articleUrl').value = item.link;
                    await openTool(null, 'ArticleExtractor');
                    await ae_startExtraction(true);
                    window.scrollTo(0, 0);
                };
            }

            const toggleButton = articleDiv.querySelector('.rss-read-toggle-btn');
            if (toggleButton) {
                toggleButton.onclick = async (e) => {
                    e.stopPropagation();
                    if (await isRssArticleRead(feed.url, item.link)) {
                        await markRssArticleAsUnread(feed.url, item.link);
                    } else {
                        await markRssArticleAsRead(feed.url, item.link);
                    }
                    await displayRssFeedArticles(feed);
                };
            }
            articlesListDiv.appendChild(articleDiv);
        }

        const rssFeedsTab = document.getElementById('RSSFeeds');
        if (rssFeedsTab && rssFeedsTab.style.display !== 'none' && articlesListDiv.children.length > 1) {
            articlesListDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }
    async function deleteRssFeed(index) {
        if (!confirm("рдХреНрдпрд╛ рдЖрдк рд╡рд╛рдХрдИ рдЗрд╕ RSS рдлрд╝реАрдб рдХреЛ рд╣рдЯрд╛рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ?")) return;
        const feeds = await getSubscribedFeeds();
        if (index < 0 || index >= feeds.length) { showToast("рдЕрдорд╛рдиреНрдп рдлрд╝реАрдб рдЗрдВрдбреЗрдХреНрд╕ред", "error"); return; }
        const feedToDelete = feeds[index];

        await db.rss_feeds.delete(feedToDelete.url);
        const updatedFeeds = await getSubscribedFeeds();

        if (feedToDelete && feedToDelete.url) {
            const readItems = await getRssReadItems();
            if (readItems[feedToDelete.url]) {
                delete readItems[feedToDelete.url];
                await saveRssReadItems(readItems);
            }
        }

        if (updatedFeeds.length === 0) {
            document.getElementById('rssFeedTitleDisplay').textContent = '';
            document.getElementById('rssArticlesList').innerHTML = '';
        } else {
            const currentDisplayTitle = document.getElementById('rssFeedTitleDisplay').textContent;
            if (feedToDelete && currentDisplayTitle.includes(feedToDelete.title || feedToDelete.url)) {
                await displayRssFeedArticles(updatedFeeds[0]);
            }
        }
        await displaySubscribedFeeds();
        await updateRssFeedCount();
        showToast("RSS рдлрд╝реАрдб рд╣рдЯрд╛рдпрд╛ рдЧрдпрд╛ред", "success");
    }
    async function refreshRssFeed(index, suppressToast = false) {
        const feeds = await getSubscribedFeeds();
        if (!feeds[index]) return;
        const feedToRefresh = feeds[index];
        const refreshBtn = document.querySelector(`#subscribedFeedsList li:nth-child(${index + 1}) button[title="рд░рд┐рдлреНрд░реЗрд╢"]`);
        const originalBtnContent = refreshBtn ? refreshBtn.innerHTML : 'ЁЯФД';
        if(refreshBtn) {refreshBtn.innerHTML = 'рд▓реЛрдб...'; refreshBtn.disabled = true;}

        if (!suppressToast) showToast(`рдлрд╝реАрдб "${(feedToRefresh.title || feedToRefresh.url).substring(0,30)}..." рд░рд┐рдлреНрд░реЗрд╢ рд╣реЛ рд░рд╣рд╛ рд╣реИ...`, "info");
        try {
            const parsedFeed = await parseRssFeed(feedToRefresh.url);
            if (!parsedFeed || !parsedFeed.items) { if (!suppressToast) showToast("рдлрд╝реАрдб рдХреЛ рдкрд╛рд░реНрд╕ рдирд╣реАрдВ рдХрд┐рдпрд╛ рдЬрд╛ рд╕рдХрд╛ рдпрд╛ рдХреЛрдИ рдЖрдЗрдЯрдо рдирд╣реАрдВ рдорд┐рд▓рд╛ред", "error"); return; }
            feedToRefresh.items = parsedFeed.items.slice(0, 30);
            feedToRefresh.lastFetched = new Date().toISOString();
            feedToRefresh.title = parsedFeed.title || feedToRefresh.title;
            await db.rss_feeds.put(feedToRefresh);
            if (!suppressToast) showToast(`рдлрд╝реАрдб "${(feedToRefresh.title || feedToRefresh.url).substring(0,30)}..." рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рд░рд┐рдлреНрд░реЗрд╢ рдХрд┐рдпрд╛ рдЧрдпрд╛!`, "success");
            
            const currentDisplayTitle = document.getElementById('rssFeedTitleDisplay').textContent;
            if (currentDisplayTitle.includes(feedToRefresh.title || feedToRefresh.url)) {
                await displayRssFeedArticles(feedToRefresh);
            }
            await displaySubscribedFeeds(); // To update unread counts
        } catch (error) { console.error("рдлрд╝реАрдб рд░рд┐рдлреНрд░реЗрд╢ рдХрд░рдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐:", error); if (!suppressToast) showToast(`рдлрд╝реАрдб рд░рд┐рдлреНрд░реЗрд╢ рдХрд░рдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐: ${error.message}`, "error", 5000); }
        finally { if(refreshBtn) {refreshBtn.innerHTML = originalBtnContent; refreshBtn.disabled = false;} }
    }
    async function refreshAllRssFeeds(isAutoRefresh = false) {
        const feeds = await getSubscribedFeeds();
        if (feeds.length === 0) { if(!isAutoRefresh) showToast("рд░рд┐рдлреНрд░реЗрд╢ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдХреЛрдИ рдлрд╝реАрдб рдирд╣реАрдВ рд╣реИред", "info"); return; }

        const mainRefreshBtn = document.getElementById('refreshAllRssFeedsBtn');
        const originalMainBtnText = mainRefreshBtn.innerHTML;
        mainRefreshBtn.innerHTML = 'рдкреНрд░реЛрд╕реЗрд╕рд┐рдВрдЧ...';
        mainRefreshBtn.disabled = true;

        if (!isAutoRefresh) showToast(`рд╕рднреА ${feeds.length} рдлрд╝реАрдбреНрд╕ рд░рд┐рдлреНрд░реЗрд╢ рд╣реЛ рд░рд╣реЗ рд╣реИрдВ...`, "info", feeds.length * 1500);
        let successCount = 0;
        let errorCount = 0;

        for (const [i, feedToRefresh] of feeds.entries()) {
            const listItemRefreshBtn = document.querySelector(`#subscribedFeedsList li:nth-child(${i + 1}) button[title="рд░рд┐рдлреНрд░реЗрд╢"]`);
            const originalListItemBtnContent = listItemRefreshBtn ? listItemRefreshBtn.innerHTML : 'ЁЯФД';
            if(listItemRefreshBtn) { listItemRefreshBtn.innerHTML = 'рд▓реЛрдб...'; listItemRefreshBtn.disabled = true;}

            try {
                const parsedFeed = await parseRssFeed(feedToRefresh.url);
                if (parsedFeed && parsedFeed.items) {
                    feedToRefresh.items = parsedFeed.items.slice(0, 30);
                    feedToRefresh.lastFetched = new Date().toISOString();
                    feedToRefresh.title = parsedFeed.title || feedToRefresh.title;
                    successCount++;
                } else {
                    errorCount++;
                }
            } catch (error) {
                console.error(`рдлрд╝реАрдб ${feedToRefresh.url} рд░рд┐рдлреНрд░реЗрд╢ рдХрд░рдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐:`, error);
                errorCount++;
            } finally {
                 if(listItemRefreshBtn) { listItemRefreshBtn.innerHTML = originalListItemBtnContent; listItemRefreshBtn.disabled = false;}
            }
            if (document.getElementById('rssFeedTitleDisplay').textContent.includes(feedToRefresh.title || feedToRefresh.url)) {
                await displayRssFeedArticles(feedToRefresh);
            }
             await new Promise(resolve => setTimeout(resolve, 300));
        }
        await db.rss_feeds.bulkPut(feeds);
        await displaySubscribedFeeds();
        mainRefreshBtn.innerHTML = originalMainBtnText;
        mainRefreshBtn.disabled = false;
        if (!isAutoRefresh) showToast(`${successCount} рдлрд╝реАрдб рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рд░рд┐рдлреНрд░реЗрд╢ рд╣реБрдПред ${errorCount > 0 ? errorCount + ' рдореЗрдВ рддреНрд░реБрдЯрд┐ред' : ''}`, successCount > 0 ? "success" : "warning", 5000);
        else if (successCount > 0) showToast(`${successCount} рдлрд╝реАрдб рдСрдЯреЛ-рд░рд┐рдлреНрд░реЗрд╢ рд╣реБрдПред`, 'info', 3000);
    }

    async function clearRssFeedsData() { if (confirm('рдХреНрдпрд╛ рдЖрдк рд╡рд╛рдХрдИ рдЕрдкрдиреЗ рд╕рднреА RSS рдлрд╝реАрдбреНрд╕ рдФрд░ рдкрдврд╝реЗ рд╣реБрдП рдЖрдЗрдЯрдо рдХрд╛ рдбреЗрдЯрд╛ рд╣рдЯрд╛рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ?')) { await db.rss_feeds.clear(); await dbprefs.remove('rssReadItems'); await displaySubscribedFeeds(); await updateRssFeedCount(); document.getElementById('rssFeedTitleDisplay').textContent = ''; document.getElementById('rssArticlesList').innerHTML = ''; showToast('рд╕рднреА RSS рдлрд╝реАрдбреНрд╕ рдФрд░ рд╕рдВрдмрдВрдзрд┐рдд рдбреЗрдЯрд╛ рд╣рдЯрд╛ рджрд┐рдП рдЧрдП рд╣реИрдВред', 'success'); } }
    
    // --- OPML Functions ---
    async function exportOpml() {
        const feeds = await getSubscribedFeeds();
        if (feeds.length === 0) {
            showToast("рдПрдХреНрд╕рдкреЛрд░реНрдЯ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдХреЛрдИ рдлрд╝реАрдб рдирд╣реАрдВ рд╣реИред", "warning");
            return;
        }
        let opml = '<?xml version="1.0" encoding="UTF-8"?><opml version="2.0"><body>';
        feeds.forEach(feed => {
            const title = feed.title.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
            const url = feed.url.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
            opml += `<outline type="rss" text="${title}" title="${title}" xmlUrl="${url}" />`;
        });
        opml += '</body></opml>';

        const blob = new Blob([opml], { type: 'application/xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'rss_feeds_export.opml';
        a.click();
        URL.revokeObjectURL(url);
        showToast("OPML рдлрд╝рд╛рдЗрд▓ рдПрдХреНрд╕рдкреЛрд░реНрдЯ рдХреА рдЧрдИ!", "success");
    }

    function importOpml(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const xmlText = e.target.result;
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, "application/xml");
                const outlines = xmlDoc.querySelectorAll('outline[type="rss"]');
                if (outlines.length === 0) {
                    showToast("рдЗрд╕ OPML рдлрд╝рд╛рдЗрд▓ рдореЗрдВ рдХреЛрдИ RSS рдлрд╝реАрдб рдирд╣реАрдВ рдорд┐рд▓рд╛ред", "error");
                    return;
                }
                
                showToast(`${outlines.length} рдлрд╝реАрдбреНрд╕ рдЗрдВрдкреЛрд░реНрдЯ рд╣реЛ рд░рд╣реЗ рд╣реИрдВ...`, "info");
                let successCount = 0;
                let failCount = 0;
                
                for (const outline of outlines) {
                    const url = outline.getAttribute('xmlUrl');
                    const title = outline.getAttribute('text') || outline.getAttribute('title');
                    if (url) {
                        const added = await addRssFeed(url, title, true); // suppressToast = true
                        if(added) successCount++;
                        else failCount++;
                    } else {
                        failCount++;
                    }
                     await new Promise(resolve => setTimeout(resolve, 100));
                }
                showToast(`${successCount} рдлрд╝реАрдбреНрд╕ рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдЗрдВрдкреЛрд░реНрдЯ рд╣реБрдПред ${failCount > 0 ? (failCount + ' рдбреБрдкреНрд▓рд┐рдХреЗрдЯ рдпрд╛ рд╡рд┐рдлрд▓ред') : ''}`, "success");

            } catch (err) {
                showToast("OPML рдлрд╝рд╛рдЗрд▓ рдХреЛ рдкрд╛рд░реНрд╕ рдХрд░рдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐: " + err.message, "error");
            }
        };
        reader.readAsText(file);
        event.target.value = null;
    }
    
    // --- RSS Auto-Refresh ---
    async function handleRssAutoRefreshChange(value) {
        const intervalMinutes = parseInt(value, 10);
        await dbprefs.set('rssAutoRefresh', intervalMinutes.toString());
        if (rssAutoRefreshIntervalId) {
            clearInterval(rssAutoRefreshIntervalId);
            rssAutoRefreshIntervalId = null;
        }
        if (intervalMinutes > 0) {
            const intervalMs = intervalMinutes * 60 * 1000;
            rssAutoRefreshIntervalId = setInterval(() => {
                console.log("Auto-refreshing RSS feeds...");
                refreshAllRssFeeds(true);
            }, intervalMs);
            showToast(`RSS рдлрд╝реАрдбреНрд╕ рдЕрдм рд╣рд░ ${intervalMinutes} рдорд┐рдирдЯ рдореЗрдВ рдСрдЯреЛ-рд░рд┐рдлреНрд░реЗрд╢ рд╣реЛрдВрдЧреЗред`, "success");
        } else {
            showToast("RSS рдСрдЯреЛ-рд░рд┐рдлреНрд░реЗрд╢ рдмрдВрдж рдХрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред", "info");
        }
    }

    async function setupRssAutoRefresh() {
        const intervalMinutes = parseInt(await dbprefs.get('rssAutoRefresh', '0'), 10);
        if (intervalMinutes > 0) {
             const intervalMs = intervalMinutes * 60 * 1000;
             setTimeout(() => {
                 console.log("Initial auto-refreshing RSS feeds...");
                 refreshAllRssFeeds(true);
             }, 5000);
             
             rssAutoRefreshIntervalId = setInterval(() => {
                console.log("Auto-refreshing RSS feeds...");
                refreshAllRssFeeds(true);
            }, intervalMs);
        }
    }


    // --- Focus Mode & Auto Scroll ---
    async function toggleFocusMode(forceState) {
        const body = document.body;
        const focusBtn = document.getElementById('focusModeToggleBtn');
        let isActive;

        if (typeof forceState === 'boolean') {
            isActive = forceState;
        } else {
            isActive = !body.classList.contains('focus-mode-active');
        }

        if (isActive) {
            body.classList.add('focus-mode-active');
            if(focusBtn) focusBtn.innerHTML = 'ЁЯзШтАНтЩАя╕П';
            showToast("рдлрд╝реЛрдХрд╕ рдореЛрдб рд╕рдХреНрд░рд┐рдпред", "info", 2000);
        } else {
            body.classList.remove('focus-mode-active');
            if(focusBtn) focusBtn.innerHTML = 'ЁЯзШ';
            showToast("рдлрд╝реЛрдХрд╕ рдореЛрдб рдирд┐рд╖реНрдХреНрд░рд┐рдпред", "info", 2000);
        }
        await dbprefs.set('focusMode', isActive);
    }

    async function applySavedFocusMode() {
        const savedFocusState = await dbprefs.get('focusMode', false);
        const focusBtn = document.getElementById('focusModeToggleBtn');
        if (savedFocusState) {
            document.body.classList.add('focus-mode-active');
            if (focusBtn) focusBtn.innerHTML = 'ЁЯзШтАНтЩАя╕П';
        } else {
             if (focusBtn) focusBtn.innerHTML = 'ЁЯзШ';
        }
    }

    function toggleAutoScroll() {
        const contentElement = document.getElementById('lib-article-text-content');
        const btn = document.getElementById('autoScrollPlayPauseBtn');

        if (isAutoScrolling) {
            clearInterval(autoScrollInterval);
            isAutoScrolling = false;
            btn.textContent = 'тЦ╢я╕П рд╢реБрд░реВ рдХрд░реЗрдВ';
            showToast("рдСрдЯреЛ-рд╕реНрдХреНрд░реЙрд▓ рд░реЛрдХрд╛ рдЧрдпрд╛ред", "info");
        } else {
            if (!contentElement || contentElement.scrollHeight <= contentElement.clientHeight) {
                showToast("рд╕реНрдХреНрд░реЙрд▓ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдкрд░реНрдпрд╛рдкреНрдд рдХрдВрдЯреЗрдВрдЯ рдирд╣реАрдВ рд╣реИред", "warning");
                return;
            }
            if (document.getElementById('lib-article-webview-container').style.display !== 'none') {
                showToast("рдСрдЯреЛ-рд╕реНрдХреНрд░реЙрд▓ рдХреЗрд╡рд▓ рд░реАрдбрд░ рд╡реНрдпреВ рдореЗрдВ рдХрд╛рдо рдХрд░рддрд╛ рд╣реИред", "warning");
                return;
            }
            isAutoScrolling = true;
            btn.textContent = 'тП╕я╕П рд░реЛрдХреЗрдВ';
            showToast("рдСрдЯреЛ-рд╕реНрдХреНрд░реЙрд▓ рд╢реБрд░реВред", "success");
            autoScrollInterval = setInterval(() => {
                if (contentElement.scrollTop + contentElement.clientHeight < contentElement.scrollHeight) {
                    contentElement.scrollTop += 1;
                } else {
                    clearInterval(autoScrollInterval);
                    isAutoScrolling = false;
                    btn.textContent = 'тЦ╢я╕П рд╢реБрд░реВ рдХрд░реЗрдВ';
                    showToast("рд▓реЗрдЦ рдХрд╛ рдЕрдВрддред рдСрдЯреЛ-рд╕реНрдХреНрд░реЙрд▓ рд╕рдорд╛рдкреНрддред", "info");
                }
            }, Math.max(10, 210 - autoScrollSpeed));
        }
    }

    function changeAutoScrollSpeed(delta) {
        autoScrollSpeed += delta;
        if (autoScrollSpeed < MIN_SCROLL_SPEED) autoScrollSpeed = MIN_SCROLL_SPEED;
        if (autoScrollSpeed > MAX_SCROLL_SPEED) autoScrollSpeed = MAX_SCROLL_SPEED;
        document.getElementById('autoScrollSpeedDisplay').textContent = `рдЧрддрд┐: ${autoScrollSpeed}`;

        if (isAutoScrolling) {
            clearInterval(autoScrollInterval);
            const contentElement = document.getElementById('lib-article-text-content');
            const btn = document.getElementById('autoScrollPlayPauseBtn');
             autoScrollInterval = setInterval(() => {
                if (contentElement.scrollTop + contentElement.clientHeight < contentElement.scrollHeight) {
                    contentElement.scrollTop += 1;
                } else {
                    clearInterval(autoScrollInterval);
                    isAutoScrolling = false;
                    if(btn) btn.textContent = 'тЦ╢я╕П рд╢реБрд░реВ рдХрд░реЗрдВ';
                }
            }, Math.max(10, 210 - autoScrollSpeed));
        }
    }

    // --- Statistics Functions ---
    async function renderStatistics() {
        const readArticles = await db.articles.where('isRead').equals(true).toArray();
        const totalReadCount = readArticles.length;
        let totalWordsRead = 0;
        const tagFrequency = {};
        const collectionFrequency = {};

        readArticles.forEach(article => {
            totalWordsRead += article.textContent ? article.textContent.split(/\s+/).filter(Boolean).length : 0;
            if (article.tags && article.tags.length > 0) {
                article.tags.forEach(tag => {
                    tagFrequency[tag] = (tagFrequency[tag] || 0) + 1;
                });
            }
            const collectionId = article.collectionId || 'uncategorized';
            collectionFrequency[collectionId] = (collectionFrequency[collectionId] || 0) + 1;
        });

        const totalReadTimeMinutes = Math.round(totalWordsRead / 200);
        const topTags = Object.entries(tagFrequency).sort((a, b) => b[1] - a[1]).slice(0, 5);
        const collections = await getCollections();
        const topCollections = Object.entries(collectionFrequency).sort((a, b) => b[1] - a[1]).slice(0, 5)
            .map(([id, count]) => {
                const collection = collections.find(c => c.id === id);
                return [collection ? collection.name : 'Uncategorized', count];
            });

        const container = document.getElementById('stats-container');
        container.innerHTML = `
            <div class="stat-card">
                <h3>рдХреБрд▓ рдорд┐рд▓рд╛рдХрд░</h3>
                <p><strong>рдкрдврд╝реЗ рдЧрдП рдХреБрд▓ рд▓реЗрдЦ:</strong> ${totalReadCount}</p>
                <p><strong>рдЕрдиреБрдорд╛рдирд┐рдд рдХреБрд▓ рдкрдврд╝рдиреЗ рдХрд╛ рд╕рдордп:</strong> ${totalReadTimeMinutes} рдорд┐рдирдЯ</p>
            </div>
            <div class="stat-card">
                <h3>рд╕рдмрд╕реЗ рд▓реЛрдХрдкреНрд░рд┐рдп рдЯреИрдЧ</h3>
                ${topTags.length > 0 ? `<ul>${topTags.map(([tag, count]) => `<li>${tag} (${count} рд▓реЗрдЦ)</li>`).join('')}</ul>` : '<p>рдХреЛрдИ рдЯреИрдЧ рдбреЗрдЯрд╛ рдирд╣реАрдВред</p>'}
            </div>
            <div class="stat-card">
                <h3>рд╕рдмрд╕реЗ рд▓реЛрдХрдкреНрд░рд┐рдп рдХрд▓реЗрдХреНрд╢рди</h3>
                ${topCollections.length > 0 ? `<ul>${topCollections.map(([name, count]) => `<li>${name} (${count} рд▓реЗрдЦ)</li>`).join('')}</ul>` : '<p>рдХреЛрдИ рдХрд▓реЗрдХреНрд╢рди рдбреЗрдЯрд╛ рдирд╣реАрдВред</p>'}
            </div>
        `;
    }

    // --- Collections Functions ---
    async function getCollections() { return await db.collections.toArray(); }
    async function saveCollections(collections) { await db.collections.bulkPut(collections); await populateCollectionFilters(); }
    async function initCollections() {
        const count = await db.collections.count();
        if (count === 0) {
            await db.collections.put({ id: 'uncategorized', name: 'Uncategorized' });
        }
    }
    async function openCollectionsModal() { await renderCollectionsListInModal(); document.getElementById('collectionsModal').classList.add('show'); }
    function closeCollectionsModal() { document.getElementById('collectionsModal').classList.remove('show'); }
    async function renderCollectionsListInModal() {
        const listDiv = document.getElementById('collections-list');
        const collections = await getCollections();
        listDiv.innerHTML = '';
        collections.forEach(c => {
            if (c.id === 'uncategorized') return;
            const itemDiv = document.createElement('div');
            itemDiv.style.display = 'flex';
            itemDiv.style.alignItems = 'center';
            itemDiv.style.marginBottom = '8px';
            itemDiv.innerHTML = `
                <span style="flex-grow:1;">${c.name}</span>
                <button onclick="renameCollection('${c.id}')" class="tool-btn-secondary" style="font-size:0.8em;padding:4px 8px;margin:0 5px;">рдирд╛рдо рдмрджрд▓реЗрдВ</button>
                <button onclick="deleteCollection('${c.id}')" class="danger-btn" style="font-size:0.8em;padding:4px 8px;margin:0;">рд╣рдЯрд╛рдПрдБ</button>
            `;
            listDiv.appendChild(itemDiv);
        });
    }
    async function addCollection() {
        const nameInput = document.getElementById('newCollectionName');
        const name = nameInput.value.trim();
        if (!name) { showToast("рдХреГрдкрдпрд╛ рдХрд▓реЗрдХреНрд╢рди рдХрд╛ рдирд╛рдо рдбрд╛рд▓реЗрдВред", "warning"); return; }
        const collections = await getCollections();
        if (collections.some(c => c.name.toLowerCase() === name.toLowerCase())) {
            showToast("рдЗрд╕ рдирд╛рдо рдХрд╛ рдХрд▓реЗрдХреНрд╢рди рдкрд╣рд▓реЗ рд╕реЗ рдореМрдЬреВрдж рд╣реИред", "error"); return;
        }
        await db.collections.put({ id: `c${new Date().getTime()}`, name: name });
        nameInput.value = '';
        await renderCollectionsListInModal();
        await populateCollectionFilters();
    }
    async function renameCollection(id) {
        const collection = await db.collections.get(id);
        if (!collection) return;
        const newName = prompt(`'${collection.name}' рдХрд╛ рдирдпрд╛ рдирд╛рдо рдХреНрдпрд╛ рд░рдЦреЗрдВ?`, collection.name);
        if (newName && newName.trim() && newName.trim() !== collection.name) {
            await db.collections.update(id, { name: newName.trim() });
            await renderCollectionsListInModal();
            await populateCollectionFilters();
        }
    }
    async function deleteCollection(id) {
        const collection = await db.collections.get(id);
        if (!collection) return;
        if (confirm(`рдХреНрдпрд╛ рдЖрдк рд╡рд╛рдХрдИ '${collection.name}' рдХрд▓реЗрдХреНрд╢рди рдХреЛ рд╣рдЯрд╛рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ? рдЗрд╕ рдХрд▓реЗрдХреНрд╢рди рдХреЗ рд╕рднреА рд▓реЗрдЦ 'Uncategorized' рдореЗрдВ рдЪрд▓реЗ рдЬрд╛рдПрдБрдЧреЗред`)) {
            await db.collections.delete(id);
            await db.articles.where('collectionId').equals(id).modify({ collectionId: 'uncategorized' });
            await renderCollectionsListInModal();
            await populateCollectionFilters();
            await loadLibrary();
        }
    }
    async function populateCollectionFilters() {
        const collections = await getCollections();
        const filterSelect = document.getElementById('libraryCollectionFilter');
        const articleSelect = document.getElementById('libArticleCollection');
        const ruleSelect = document.querySelector('#ruleActionValueContainer select');

        const currentFilterVal = filterSelect.value;
        
        filterSelect.innerHTML = '<option value="">рд╕рднреА рдХрд▓реЗрдХреНрд╢рди</option>';
        articleSelect.innerHTML = '';
        if(ruleSelect) ruleSelect.innerHTML = '';
        
        collections.sort((a,b) => a.name.localeCompare(b.name, 'hi')).forEach(c => {
            const option = `<option value="${c.id}">${c.name}</option>`;
            filterSelect.innerHTML += option;
            articleSelect.innerHTML += option;
            if(ruleSelect) ruleSelect.innerHTML += option;
        });
        filterSelect.value = currentFilterVal;
    }
    async function assignArticleToCollection(collectionId) {
        const url = document.getElementById('library-article-view').dataset.currentArticleUrl;
        if (!url || !collectionId) return;
        await db.articles.update(url, { collectionId: collectionId });
        showToast("рдХрд▓реЗрдХреНрд╢рди рдЕрдкрдбреЗрдЯ рдХрд┐рдпрд╛ рдЧрдпрд╛ред", "success", 2000);
    }

    // --- Automation Rules Functions ---
    async function getRules() { return await db.rules.toArray(); }
    async function saveRules(rules) { await db.rules.clear(); await db.rules.bulkPut(rules); await renderRulesList(); }
    async function openRuleModal(ruleId = null) {
        const modal = document.getElementById('ruleModal');
        const title = document.getElementById('ruleModalTitle');
        document.getElementById('ruleId').value = ruleId || '';
        
        if (ruleId) {
            const rule = await db.rules.get(ruleId);
            if (rule) {
                title.textContent = "рдирд┐рдпрдо рд╕рдВрдкрд╛рджрд┐рдд рдХрд░реЗрдВ";
                document.getElementById('ruleTriggerType').value = rule.trigger.type;
                await updateRuleTriggerValueUI(rule.trigger.value);
                document.getElementById('ruleActionType').value = rule.action.type;
                await updateRuleActionValueUI(rule.action.value);
            }
        } else {
            title.textContent = "рдирдпрд╛ рдирд┐рдпрдо рдмрдирд╛рдПрдБ";
            document.getElementById('ruleTriggerType').value = 'title_contains';
            await updateRuleTriggerValueUI();
            document.getElementById('ruleActionType').value = 'add_tag';
            await updateRuleActionValueUI();
        }
        modal.classList.add('show');
    }
    function closeRuleModal() { document.getElementById('ruleModal').classList.remove('show'); }
    async function updateRuleTriggerValueUI(value = '') {
        const triggerType = document.getElementById('ruleTriggerType').value;
        const container = document.getElementById('ruleTriggerValueContainer');
        if (triggerType === 'from_rss_feed') {
            const feeds = await getSubscribedFeeds();
            let selectHTML = '<select id="ruleTriggerValue" style="width:100%;">';
            feeds.forEach(feed => {
                selectHTML += `<option value="${feed.url}">${feed.title}</option>`;
            });
            selectHTML += '</select>';
            container.innerHTML = selectHTML;
            if (value) document.getElementById('ruleTriggerValue').value = value;
        } else {
            container.innerHTML = `<input type="text" id="ruleTriggerValue" placeholder="рдорд╛рди рдбрд╛рд▓реЗрдВ (рдЬреИрд╕реЗ 'urgent', 'techcrunch.com')" value="${value}">`;
        }
    }
    async function updateRuleActionValueUI(value = '') {
        const actionType = document.getElementById('ruleActionType').value;
        const container = document.getElementById('ruleActionValueContainer');
        if (actionType === 'assign_collection') {
            let selectHTML = '<select id="ruleActionValue" style="width:100%;">';
            (await getCollections()).forEach(c => {
                selectHTML += `<option value="${c.id}">${c.name}</option>`;
            });
            selectHTML += '</select>';
            container.innerHTML = selectHTML;
            if (value) document.getElementById('ruleActionValue').value = value;
        } else {
            container.innerHTML = `<input type="text" id="ruleActionValue" placeholder="рдЯреИрдЧ рдХрд╛ рдирд╛рдо (рдЬреИрд╕реЗ 'work', 'important')" value="${value}">`;
        }
    }
    async function saveRule() {
        const id = document.getElementById('ruleId').value;
        const triggerType = document.getElementById('ruleTriggerType').value;
        const triggerValue = document.getElementById('ruleTriggerValue').value;
        const actionType = document.getElementById('ruleActionType').value;
        const actionValue = document.getElementById('ruleActionValue').value;

        if (!triggerValue || !actionValue) {
            showToast("рдХреГрдкрдпрд╛ рдирд┐рдпрдо рдХреЗ рд╕рднреА рдорд╛рди рднрд░реЗрдВред", "error");
            return;
        }

        const newRule = {
            id: id || `rule${new Date().getTime()}`,
            trigger: { type: triggerType, value: triggerValue },
            action: { type: actionType, value: actionValue }
        };

        await db.rules.put(newRule);
        await renderRulesList();
        closeRuleModal();
        showToast("рдирд┐рдпрдо рд╕рд╣реЗрдЬрд╛ рдЧрдпрд╛ред", "success");
    }
    async function deleteRule(id) {
        if (confirm("рдХреНрдпрд╛ рдЖрдк рд╡рд╛рдХрдИ рдЗрд╕ рдирд┐рдпрдо рдХреЛ рд╣рдЯрд╛рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ?")) {
            await db.rules.delete(id);
            await renderRulesList();
            showToast("рдирд┐рдпрдо рд╣рдЯрд╛рдпрд╛ рдЧрдпрд╛ред", "info");
        }
    }
    async function renderRulesList() {
        const container = document.getElementById('rulesListContainer');
        const rules = await getRules();
        container.innerHTML = '';
        if (rules.length === 0) {
            container.innerHTML = '<p style="font-style:italic; font-size:0.9em;">рдХреЛрдИ рдирд┐рдпрдо рдирд╣реАрдВ рдмрдирд╛рдпрд╛ рдЧрдпрд╛ рд╣реИред</p>';
            return;
        }
        rules.forEach(rule => {
            const itemDiv = document.createElement('div');
            itemDiv.style.display = 'flex';
            itemDiv.style.alignItems = 'center';
            itemDiv.style.marginBottom = '8px';
            itemDiv.innerHTML = `
                <span style="flex-grow:1; font-size:0.9em;">IF ${rule.trigger.type.replace('_',' ')}: "${(rule.trigger.value || '').substring(0,20)}..." THEN ${rule.action.type.replace('_',' ')}: "${(rule.action.value || '').substring(0,20)}..."</span>
                <button onclick="openRuleModal('${rule.id}')" class="tool-btn-secondary" style="font-size:0.8em;padding:4px 8px;margin:0 5px;">рд╕рдВрдкрд╛рджрд┐рдд рдХрд░реЗрдВ</button>
                <button onclick="deleteRule('${rule.id}')" class="danger-btn" style="font-size:0.8em;padding:4px 8px;margin:0;">рд╣рдЯрд╛рдПрдБ</button>
            `;
            container.appendChild(itemDiv);
        });
    }
    async function applyAutomationRules(articleData) {
        const rules = await getRules();
        let modifiedArticle = { ...articleData };

        for(const rule of rules) {
            let triggerMet = false;
            switch(rule.trigger.type) {
                case 'title_contains':
                    if (modifiedArticle.title.toLowerCase().includes(rule.trigger.value.toLowerCase())) triggerMet = true;
                    break;
                case 'url_contains':
                     if (modifiedArticle.url.toLowerCase().includes(rule.trigger.value.toLowerCase())) triggerMet = true;
                    break;
                case 'from_rss_feed':
                    if (modifiedArticle.sourceFeedUrl === rule.trigger.value) triggerMet = true;
                    break;
            }

            if (triggerMet) {
                switch(rule.action.type) {
                    case 'add_tag':
                        modifiedArticle.tags = modifiedArticle.tags || [];
                        if (!modifiedArticle.tags.includes(rule.action.value)) {
                            modifiedArticle.tags.push(rule.action.value);
                            showToast(`рдирд┐рдпрдо рд▓рд╛рдЧреВ: рдЯреИрдЧ '${rule.action.value}' рдЬреЛрдбрд╝рд╛ рдЧрдпрд╛ред`, "info", 2000);
                        }
                        break;
                    case 'assign_collection':
                        modifiedArticle.collectionId = rule.action.value;
                        const coll = await db.collections.get(rule.action.value);
                        showToast(`рдирд┐рдпрдо рд▓рд╛рдЧреВ: '${(coll ? coll.name : 'Unknown')}' рдХрд▓реЗрдХреНрд╢рди рдореЗрдВ рдбрд╛рд▓рд╛ рдЧрдпрд╛ред`, "info", 2000);
                        break;
                }
            }
        }
        return modifiedArticle;
    }


    // --- DATA MIGRATION FROM LOCALSTORAGE TO DEXIE ---
    async function runMigration() {
        const isMigrated = localStorage.getItem('isMigratedToDexie_v1');
        if (isMigrated) return;

        showToast('рдбреЗрдЯрд╛ рдХреЛ рдирдП рдбреЗрдЯрд╛рдмреЗрд╕ рдореЗрдВ рдорд╛рдЗрдЧреНрд░реЗрдЯ рдХрд┐рдпрд╛ рдЬрд╛ рд░рд╣рд╛ рд╣реИ...', 'info', 10000);
        
        try {
            await db.transaction('rw', db.articles, db.collections, db.rules, db.bookmarks, db.rss_feeds, db.preferences, db.runtime_state, async () => {
                
                function tryParse(value, defaultValue) {
                    if (value === null || value === undefined) return defaultValue;
                    try { return JSON.parse(value); } catch(e) { return defaultValue; }
                }

                // Migrate Library
                const oldLibrary = tryParse(localStorage.getItem(OLD_STORAGE_KEYS.library), {});
                const articlesToMigrate = Object.values(oldLibrary).map(article => ({ ...article, id: undefined }));
                if (articlesToMigrate.length > 0) await db.articles.bulkPut(articlesToMigrate);

                // Migrate Collections
                const oldCollections = tryParse(localStorage.getItem(OLD_STORAGE_KEYS.collections), []);
                if (oldCollections.length > 0) await db.collections.bulkPut(oldCollections);
                
                // Migrate Rules
                const oldRules = tryParse(localStorage.getItem(OLD_STORAGE_KEYS.rules), []);
                if (oldRules.length > 0) await db.rules.bulkPut(oldRules);

                // Migrate Bookmarks
                const oldBookmarks = tryParse(localStorage.getItem(OLD_STORAGE_KEYS.bookmarks), []);
                if (oldBookmarks.length > 0) await db.bookmarks.bulkPut(oldBookmarks);

                // Migrate RSS Feeds
                const oldRssFeeds = tryParse(localStorage.getItem(OLD_STORAGE_KEYS.rssFeeds), []);
                if (oldRssFeeds.length > 0) await db.rss_feeds.bulkPut(oldRssFeeds);
                
                // Migrate runtime state
                const oldQueue = tryParse(localStorage.getItem(OLD_STORAGE_KEYS.playQueue), null);
                if (oldQueue) await db.runtime_state.put({ key: 'playQueue', value: oldQueue });

                // Migrate all other settings to preferences table
                for (const key in OLD_STORAGE_KEYS) {
                    if (['library', 'collections', 'rules', 'bookmarks', 'rssFeeds', 'playQueue', 'theme'].includes(key)) continue;
                    const lsKey = OLD_STORAGE_KEYS[key];
                    const value = localStorage.getItem(lsKey);
                    if (value !== null) {
                         // Don't re-parse if it's already a string from localStorage
                        await dbprefs.set(key, tryParse(value, value));
                    }
                }
                const themeVal = localStorage.getItem(OLD_STORAGE_KEYS.theme);
                if (themeVal) await dbprefs.set('theme', themeVal);
            });

            localStorage.setItem('isMigratedToDexie_v1', 'true');
            showToast('рдбреЗрдЯрд╛ рдорд╛рдЗрдЧреНрд░реЗрд╢рди рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдкреВрд░рд╛ рд╣реБрдЖ!', 'success', 5000);
            
            Object.values(OLD_STORAGE_KEYS).forEach(key => localStorage.removeItem(key));
            showToast('рдкреБрд░рд╛рдирд╛ рдбреЗрдЯрд╛ рд╕рд╛рдлрд╝ рдХрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред', 'info', 3000);

        } catch (error) {
            console.error("Dexie рдорд╛рдЗрдЧреНрд░реЗрд╢рди рдореЗрдВ рддреНрд░реБрдЯрд┐:", error);
            showToast("рдбреЗрдЯрд╛ рдорд╛рдЗрдЧреНрд░реЗрд╢рди рдореЗрдВ рддреНрд░реБрдЯрд┐! рдХрдВрд╕реЛрд▓ рджреЗрдЦреЗрдВред", "error", 10000);
        }
    }


    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', async () => {
        await runMigration(); // Run migration first
        await loadQueue();
        await initCollections();
        await applySavedTheme();
        await updateLibraryCount(); 
        await updateBookmarkCount(); 
        await updateRssFeedCount();
        await applySavedFontSize(); 
        await applySavedLibraryFontSize(); 
        await applySavedDisplayMode();
        await applySavedFocusMode();
        await setupRssAutoRefresh();
        toggleDepthSelector(); 
        await populateTagFilter(); 
        await populateCollectionFilters(); 
        await populateBookmarkFolderSelectors();
        
        if (speechApiSupported) {
            localSpeechSynth = window.speechSynthesis;
            const loadVoices = async () => {
                const voices = localSpeechSynth.getVoices();
                if (voices.length > 0) {
                    await populateVoiceSelector();
                } else if (localSpeechSynth.onvoiceschanged === undefined) {
                    setTimeout(loadVoices, 200);
                }
            };
            await loadVoices();
            if (localSpeechSynth.onvoiceschanged !== undefined) {
                localSpeechSynth.onvoiceschanged = loadVoices;
            }
        }
        await applySavedTTSSettings();
        const autoPlay = await dbprefs.get('autoplay', false);
        if (autoPlay) document.getElementById('autoPlayNextToggle').checked = true;

        document.addEventListener('visibilitychange', () => {});

        window.addEventListener('beforeunload', async () => { if (isPlaying || isPaused) { await stopTTS(); } });

        if (mediaSessionSupported) {
            navigator.mediaSession.setActionHandler('play', () => handlePlayPause());
            navigator.mediaSession.setActionHandler('pause', () => handlePlayPause());
            navigator.mediaSession.setActionHandler('stop', () => stopTTS());
            navigator.mediaSession.setActionHandler('previoustrack', () => playPreviousInQueue());
            navigator.mediaSession.setActionHandler('nexttrack', () => playNextInQueueOrAutoplay());
        }

        const g=document.getElementById('googleSearchQuery');if(g)g.addEventListener('keypress',(e)=>{if(e.key==='Enter'){e.preventDefault();performGoogleSearch();}});
        const p=new URLSearchParams(window.location.search),url=p.get('url'),r=document.getElementById('ae_result'),i=document.getElementById('articleUrl');
        if(url){if(i)i.value=url;ae_startExtraction();}
        const tab=document.querySelector('.tab-link');if(tab&&!url)openTool({currentTarget:tab},'ArticleExtractor');else if(url)openTool({currentTarget:document.querySelector('.tab-link[onclick*="ArticleExtractor"]')},'ArticleExtractor');
        updateHistoryButtons();
        updatePlayerUI();

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                try {
                    const blob = new Blob([serviceWorkerCode], { type: 'application/javascript' });
                    navigator.serviceWorker.register(URL.createObjectURL(blob))
                        .then(reg => console.log('ServiceWorker registered successfully for PWA.', reg))
                        .catch(err => console.error('ServiceWorker registration failed:', err));
                } catch (e) {
                    console.error('Blob-based ServiceWorker creation failed:', e);
                }
            });
        }
    });
    </script>
</body>
                                    </html>
